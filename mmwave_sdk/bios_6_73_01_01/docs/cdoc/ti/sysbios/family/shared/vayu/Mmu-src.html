<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.family.shared.vayu.Mmu</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2014, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Mmu.xdc ========
</span>    34    <span class="comment"> */</span>
    35    
    36    <span class=key>package</span> ti.sysbios.family.shared.vayu;
    37    
    38    import xdc.rov.ViewInfo;
    39    
    40    import xdc.runtime.Assert;
    41    
    42    <span class="xdoc">/*!
</span>    43    <span class="xdoc"> *  ======== Mmu ========
</span>    44    <span class="xdoc"> *  DSP Memory Management Unit (MMU0) Manager.
</span>    45    <span class="xdoc"> *
</span>    46    <span class="xdoc"> *  This module allows the processor to map a virtual address to a
</span>    47    <span class="xdoc"> *  different physical address and enable/disable the MMU.  It does this
</span>    48    <span class="xdoc"> *  through a translation table in memory.  The translation table is
</span>    49    <span class="xdoc"> *  16KB and manages only the first level descriptor table.  Each entry
</span>    50    <span class="xdoc"> *  in the table defines the memory translation of a page of size 1MB
</span>    51    <span class="xdoc"> *  (or 16MB if using supersections).
</span>    52    <span class="xdoc"> *
</span>    53    <span class="xdoc"> *  By default, the MMU translation table is initialized with
</span>    54    <span class="xdoc"> *  entries for every memory segment defined in the platform.
</span>    55    <span class="xdoc"> *  Entries are also added for the peripheral addresses used by
</span>    56    <span class="xdoc"> *  SYS/BIOS (i.e. Timers, Interrupt controller).
</span>    57    <span class="xdoc"> *
</span>    58    <span class="xdoc"> *  The translation table is placed in
</span>    59    <span class="xdoc"> *  an output section called "ti.sysbios.family.shared.vayu.mmuTableSection".
</span>    60    <span class="xdoc"> *  This section is placed into the platform's default dataMemory and
</span>    61    <span class="xdoc"> *  in order to minimize object file size, specified to not be initialized
</span>    62    <span class="xdoc"> *  via the "NOLOAD" type on GNU compilers and "NOINIT" on TI compilers.
</span>    63    <span class="xdoc"> *
</span>    64    <span class="xdoc"> *  This module does not manage the second level descriptor tables.
</span>    65    <span class="xdoc"> *  A 'SECTION' mapped access requires only a first level fetch.  In
</span>    66    <span class="xdoc"> *  this case, there is no need for a second level descriptor table.
</span>    67    <span class="xdoc"> *  A 'PAGE_TABLE' mapped access requires a second level
</span>    68    <span class="xdoc"> *  descriptor table which can be supplied by the user.
</span>    69    <span class="xdoc"> *
</span>    70    <span class="xdoc"> *  The following is an example of how to place the MMU table
</span>    71    <span class="xdoc"> *  for the address range 0x80000000-0x90000000 in the *.cfg file:
</span>    72    <span class="xdoc"> *
</span>    73    <span class="xdoc"> *  <b>@p(code)</b>
</span>    74    <span class="xdoc"> *
</span>    75    <span class="xdoc"> *    var Mmu = xdc.useModule('ti.sysbios.family.shared.vayu.Mmu');
</span>    76    <span class="xdoc"> *
</span>    77    <span class="xdoc"> *    // Enable the MMU
</span>    78    <span class="xdoc"> *    Mmu.enableMMU = true;
</span>    79    <span class="xdoc"> *
</span>    80    <span class="xdoc"> *    // descriptor attribute structure
</span>    81    <span class="xdoc"> *    var attrs = {
</span>    82    <span class="xdoc"> *        type: Mmu.FirstLevelDesc_SECTION,  // SECTION descriptor
</span>    83    <span class="xdoc"> *        supersection: false
</span>    84    <span class="xdoc"> *    };
</span>    85    <span class="xdoc"> *
</span>    86    <span class="xdoc"> *    // Set the descriptor for each entry in the address range
</span>    87    <span class="xdoc"> *    for (var i=0x80000000; i &lt; 0x90000000; i = i + 0x00100000) {
</span>    88    <span class="xdoc"> *        // Each 'SECTION' descriptor entry spans a 1MB address range
</span>    89    <span class="xdoc"> *        Mmu.setFirstLevelDescMeta(i, i, attrs);
</span>    90    <span class="xdoc"> *    }
</span>    91    <span class="xdoc"> *
</span>    92    <span class="xdoc"> *    var memmap = Program.cpu.memoryMap;
</span>    93    <span class="xdoc"> *    var DDR = null;
</span>    94    <span class="xdoc"> *
</span>    95    <span class="xdoc"> *    // Find DDR in memory map
</span>    96    <span class="xdoc"> *    for (var i=0; i &lt; memmap.length; i++) {
</span>    97    <span class="xdoc"> *        if (memmap[i].name == "DDR") {
</span>    98    <span class="xdoc"> *            DDR = memmap[i];
</span>    99    <span class="xdoc"> *        }
</span>   100    <span class="xdoc"> *    }
</span>   101    <span class="xdoc"> *
</span>   102    <span class="xdoc"> *    // Place the MMU table in the DDR memory segment if it exists
</span>   103    <span class="xdoc"> *    if (DDR != null) {
</span>   104    <span class="xdoc"> *        var sectionName = "ti.sysbios.family.shared.vayu.mmuTableSection";
</span>   105    <span class="xdoc"> *        Program.sectMap[sectionName] = new Program.SectionSpec();
</span>   106    <span class="xdoc"> *        Program.sectMap[sectionName].type = "NOINIT"; // NOLOAD for GNU Tools
</span>   107    <span class="xdoc"> *        Program.sectMap[sectionName].loadSegment = "DDR";
</span>   108    <span class="xdoc"> *    }
</span>   109    <span class="xdoc"> *    else {
</span>   110    <span class="xdoc"> *        print("No DDR memory segment was found");
</span>   111    <span class="xdoc"> *    }
</span>   112    <span class="xdoc"> *
</span>   113    <span class="xdoc"> *  <b>@p</b>
</span>   114    <span class="xdoc"> *
</span>   115    <span class="xdoc"> *  The following is an example of how to add TLB entries and lock them:
</span>   116    <span class="xdoc"> *
</span>   117    <span class="xdoc"> *  <b>@p(code)</b>
</span>   118    <span class="xdoc"> *  #include &lt;ti/sysbios/family/shared/vayu/Mmu.h&gt;
</span>   119    <span class="xdoc"> *
</span>   120    <span class="xdoc"> *  Int main()
</span>   121    <span class="xdoc"> *  {
</span>   122    <span class="xdoc"> *      Int i, j;
</span>   123    <span class="xdoc"> *      Bool ret;
</span>   124    <span class="xdoc"> *
</span>   125    <span class="xdoc"> *      // Add and lock 16 TLB entries. Once the entries are locked, they
</span>   126    <span class="xdoc"> *      // cannot be evicted by the table walking logic when the MMU is enabled.
</span>   127    <span class="xdoc"> *      for (i = 0x90000000, j = 0; j &lt; 16; i+= 0x1000, j++) {
</span>   128    <span class="xdoc"> *          ret = Mmu_writeTLBEntry((Ptr)i, (Ptr)i, Mmu_PageSize_SMALL);
</span>   129    <span class="xdoc"> *          if (!ret) {
</span>   130    <span class="xdoc"> *              // FAILED: Could not lock TLB entry. TLB is full with locked
</span>   131    <span class="xdoc"> *              // entries.
</span>   132    <span class="xdoc"> *              ...
</span>   133    <span class="xdoc"> *          }
</span>   134    <span class="xdoc"> *      }
</span>   135    <span class="xdoc"> *      ...
</span>   136    <span class="xdoc"> *      BIOS_start();
</span>   137    <span class="xdoc"> *  }
</span>   138    <span class="xdoc"> *  <b>@p</b>
</span>   139    <span class="xdoc"> *
</span>   140    <span class="xdoc"> *  The following is an example of how to unlock and clear TLB entries:
</span>   141    <span class="xdoc"> *
</span>   142    <span class="xdoc"> *  <b>@p(code)</b>
</span>   143    <span class="xdoc"> *  #include &lt;ti/sysbios/family/shared/vayu/Mmu.h&gt;
</span>   144    <span class="xdoc"> *
</span>   145    <span class="xdoc"> *  Int func()
</span>   146    <span class="xdoc"> *  {
</span>   147    <span class="xdoc"> *      Int i, j;
</span>   148    <span class="xdoc"> *
</span>   149    <span class="xdoc"> *      // Unlock all TLB entries by setting locked entries base value to 0
</span>   150    <span class="xdoc"> *      Mmu_setTLBLockBaseValue(0);
</span>   151    <span class="xdoc"> *
</span>   152    <span class="xdoc"> *      // Clear (or flush) TLB entries pointed to by given virtual address.
</span>   153    <span class="xdoc"> *      for (i = 0x90000000, j = 0; j &lt; 16; i+= 0x1000, j++) {
</span>   154    <span class="xdoc"> *          Mmu_clearTLBEntry((Ptr)i);
</span>   155    <span class="xdoc"> *      }
</span>   156    <span class="xdoc"> *      ...
</span>   157    <span class="xdoc"> *  }
</span>   158    <span class="xdoc"> *  <b>@p</b>
</span>   159    <span class="xdoc"> *
</span>   160    <span class="xdoc"> *  The following example shows how to add a second level descriptor table:
</span>   161    <span class="xdoc"> *
</span>   162    <span class="xdoc"> *  <b>@p(code)</b>
</span>   163    <span class="xdoc"> *  #include &lt;ti/sysbios/BIOS.h&gt;
</span>   164    <span class="xdoc"> *  #include &lt;ti/sysbios/family/shared/vayu/Mmu.h&gt;
</span>   165    <span class="xdoc"> *
</span>   166    <span class="xdoc"> *  #define MMU_LEVEL2DESC_LARGEPAGE    0x1
</span>   167    <span class="xdoc"> *  #define MMU_LEVEL2DESC_SMALLPAGE    0x2
</span>   168    <span class="xdoc"> *
</span>   169    <span class="xdoc"> *  #pragma DATA_ALIGN(mmuL2Table, 4096);    // align to 4KB
</span>   170    <span class="xdoc"> *
</span>   171    <span class="xdoc"> *  UInt32 mmuL2Table[256];
</span>   172    <span class="xdoc"> *
</span>   173    <span class="xdoc"> *  Void main(Int argc, Char * argv[])
</span>   174    <span class="xdoc"> *  {
</span>   175    <span class="xdoc"> *      Mmu_FirstLevelDescAttrs attrs;
</span>   176    <span class="xdoc"> *      Int i, j;
</span>   177    <span class="xdoc"> *
</span>   178    <span class="xdoc"> *      // initialize the second level descriptors
</span>   179    <span class="xdoc"> *      for (i = 0x80000000, j = 0; j &lt; 256; i+= 0x1000, j++) {
</span>   180    <span class="xdoc"> *          mmuL2Table[j] = (i &amp; 0xFFFFF000) | MMU_LEVEL2DESC_SMALLPAGE;
</span>   181    <span class="xdoc"> *
</span>   182    <span class="xdoc"> *          // For large pages use below line instead:
</span>   183    <span class="xdoc"> *          // mmuL2Table[j] = (i &amp; 0xFFFF0000) | MMU_LEVEL2DESC_LARGEPAGE;
</span>   184    <span class="xdoc"> *      }
</span>   185    <span class="xdoc"> *
</span>   186    <span class="xdoc"> *      // first level descriptor properites
</span>   187    <span class="xdoc"> *      Mmu_initDescAttrs(&amp;attrs);
</span>   188    <span class="xdoc"> *      attrs.type = Mmu_FirstLevelDesc_PAGE_TABLE; // set to a page table descriptor
</span>   189    <span class="xdoc"> *
</span>   190    <span class="xdoc"> *      // Set the first level descriptor for the virtual address 0x80000000.
</span>   191    <span class="xdoc"> *      // No need to disable the MMU. The API should internally disable and
</span>   192    <span class="xdoc"> *      // re-enable it.
</span>   193    <span class="xdoc"> *      Mmu_setFirstLevelDesc((Ptr)0x80000000, &amp;mmuL2Table, &amp;attrs);
</span>   194    <span class="xdoc"> *
</span>   195    <span class="xdoc"> *      BIOS_start();
</span>   196    <span class="xdoc"> *  }
</span>   197    <span class="xdoc"> *
</span>   198    <span class="xdoc"> *  ...
</span>   199    <span class="xdoc"> *  <b>@p</b>
</span>   200    <span class="xdoc"> *
</span>   201    <span class="xdoc"> *  Notes:
</span>   202    <span class="xdoc"> *  <b>@p(blist)</b>
</span>   203    <span class="xdoc"> *      -There are size and alignment requirements on the second
</span>   204    <span class="xdoc"> *       level descriptor tables depending on the page size.
</span>   205    <span class="xdoc"> *      -See the SoC Reference Manual for more info.
</span>   206    <span class="xdoc"> *  <b>@p</b>
</span>   207    <span class="xdoc"> *
</span>   208    <span class="xdoc"> *  <b>@p(html)</b>
</span>   209    <span class="xdoc"> *  &lt;h3&gt; Calling Context &lt;/h3&gt;
</span>   210    <span class="xdoc"> *  &lt;table border="1" cellpadding="3"&gt;
</span>   211    <span class="xdoc"> *    &lt;colgroup span="1"&gt;&lt;/colgroup&gt; &lt;colgroup span="5" align="center"&gt;
</span>   212    <span class="xdoc"> *    &lt;/colgroup&gt;
</span>   213    <span class="xdoc"> *
</span>   214    <span class="xdoc"> *    &lt;tr&gt;&lt;th&gt; Function                 &lt;/th&gt;&lt;th&gt;  Hwi   &lt;/th&gt;&lt;th&gt;  Swi   &lt;/th&gt;
</span>   215    <span class="xdoc"> *    &lt;th&gt;  Task  &lt;/th&gt;&lt;th&gt;  Main  &lt;/th&gt;&lt;th&gt;  Startup  &lt;/th&gt;&lt;/tr&gt;
</span>   216    <span class="xdoc"> *    &lt;!--                               --&gt;
</span>   217    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #clearTLBEntry}&lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   218    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   219    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #disable}    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   220    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   221    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #enable}     &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   222    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   223    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #initDescAttrs}   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   224    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   225    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #isEnabled}   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   226    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   227    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setFirstLevelDesc}&lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   228    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   229    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setTLBLockBaseValue}&lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y  &lt;/td&gt;
</span>   230    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   231    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #writeTLBEntry}&lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   232    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   233    <span class="xdoc"> *    &lt;tr&gt;&lt;td colspan="6"&gt; Definitions: &lt;br /&gt;
</span>   234    <span class="xdoc"> *       &lt;ul&gt;
</span>   235    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Hwi&lt;/b&gt;: API is callable from a Hwi thread. &lt;/li&gt;
</span>   236    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Swi&lt;/b&gt;: API is callable from a Swi thread. &lt;/li&gt;
</span>   237    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Task&lt;/b&gt;: API is callable from a Task thread. &lt;/li&gt;
</span>   238    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Main&lt;/b&gt;: API is callable during any of these phases: &lt;/li&gt;
</span>   239    <span class="xdoc"> *           &lt;ul&gt;
</span>   240    <span class="xdoc"> *             &lt;li&gt; In your module startup after this module is started
</span>   241    <span class="xdoc"> *   (e.g. Cache_Module_startupDone() returns TRUE). &lt;/li&gt;
</span>   242    <span class="xdoc"> *             &lt;li&gt; During xdc.runtime.Startup.lastFxns. &lt;/li&gt;
</span>   243    <span class="xdoc"> *             &lt;li&gt; During main().&lt;/li&gt;
</span>   244    <span class="xdoc"> *             &lt;li&gt; During BIOS.startupFxns.&lt;/li&gt;
</span>   245    <span class="xdoc"> *           &lt;/ul&gt;
</span>   246    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Startup&lt;/b&gt;: API is callable during any of these phases:&lt;/li&gt;
</span>   247    <span class="xdoc"> *           &lt;ul&gt;
</span>   248    <span class="xdoc"> *             &lt;li&gt; During xdc.runtime.Startup.firstFxns.&lt;/li&gt;
</span>   249    <span class="xdoc"> *             &lt;li&gt; In your module startup before this module is started
</span>   250    <span class="xdoc"> *   (e.g. Cache_Module_startupDone() returns FALSE).&lt;/li&gt;
</span>   251    <span class="xdoc"> *           &lt;/ul&gt;
</span>   252    <span class="xdoc"> *       &lt;/ul&gt;
</span>   253    <span class="xdoc"> *    &lt;/td&gt;&lt;/tr&gt;
</span>   254    <span class="xdoc"> *
</span>   255    <span class="xdoc"> *  &lt;/table&gt;
</span>   256    <span class="xdoc"> *  <b>@p</b>
</span>   257    <span class="xdoc"> */</span>
   258    
   259    @Template (<span class="string">"./Mmu.xdt"</span>) <span class="comment">/* generate function to init MMU page table */</span>
   260    @ModuleStartup          <span class="comment">/* call to initTableBuf() in startup */</span>
   261    @DirectCall
   262    
   263    <span class=key>module</span> Mmu
   264    {
   265        <span class=comment>// -------- ROV views --------</span>
   266    
   267        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
   268        <span class=key>metaonly</span> <span class=key>struct</span> PageView {
   269            String      Type;
   270            Ptr         AddrVirtual;
   271            Ptr         AddrPhysical;
   272            Ptr         Level2TablePtr;
   273            Bool        SuperSection;
   274        };
   275    
   276        @Facet
   277        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo =
   278            ViewInfo.create({
   279                viewMap: [
   280                    [<span class="string">'0x0-0x7FFFFFFF'</span>, {
   281                        type: ViewInfo.MODULE_DATA,
   282                        viewInitFxn: <span class="string">'viewPages1'</span>,
   283                        structName: <span class="string">'PageView'</span>
   284                    }],
   285                    [<span class="string">'0x80000000-0x9FFFFFFF'</span>, {
   286                        type: ViewInfo.MODULE_DATA,
   287                        viewInitFxn: <span class="string">'viewPages2'</span>,
   288                        structName: <span class="string">'PageView'</span>
   289                    }],
   290                    [<span class="string">'0xA0000000-0xBFFFFFFF'</span>, {
   291                        type: ViewInfo.MODULE_DATA,
   292                        viewInitFxn: <span class="string">'viewPages3'</span>,
   293                        structName: <span class="string">'PageView'</span>
   294                    }],
   295                    [<span class="string">'0xC0000000-0xDFFFFFFF'</span>, {
   296                        type: ViewInfo.MODULE_DATA,
   297                        viewInitFxn: <span class="string">'viewPages4'</span>,
   298                        structName: <span class="string">'PageView'</span>
   299                    }],
   300                    [<span class="string">'0xE0000000-0xFFFFFFFF'</span>, {
   301                        type: ViewInfo.MODULE_DATA,
   302                        viewInitFxn: <span class="string">'viewPages5'</span>,
   303                        structName: <span class="string">'PageView'</span>
   304                    }]
   305               ]
   306           });
   307    
   308        <span class="xdoc">/*!
</span>   309    <span class="xdoc">     *  First Level descriptors
</span>   310    <span class="xdoc">     *
</span>   311    <span class="xdoc">     *  Different descriptor type encodings:
</span>   312    <span class="xdoc">     *  0b00    -&gt;  Invalid or Fault entry
</span>   313    <span class="xdoc">     *  0b01    -&gt;  Page table entry
</span>   314    <span class="xdoc">     *  0b10    -&gt;  Section descriptor
</span>   315    <span class="xdoc">     */</span>
   316        <span class=key>enum</span> FirstLevelDesc {
   317            FirstLevelDesc_FAULT = 0,      <span class="xdoc">/*! Virtual address is unmapped     */</span>
   318            FirstLevelDesc_PAGE_TABLE = 1, <span class="xdoc">/*! Page table addr descriptor      */</span>
   319            FirstLevelDesc_SECTION = 2     <span class="xdoc">/*! Section descriptor              */</span>
   320        };
   321    
   322        <span class="xdoc">/*!
</span>   323    <span class="xdoc">     *  Page size
</span>   324    <span class="xdoc">     */</span>
   325        <span class=key>enum</span> PageSize {
   326            PageSize_SECTION = 0,          <span class="xdoc">/*! Section (1 MB) */</span>
   327            PageSize_LARGE = 1,            <span class="xdoc">/*! Large page (64 KB) */</span>
   328            PageSize_SMALL = 2,            <span class="xdoc">/*! Small page (4 KB) */</span>
   329            PageSize_SUPERSECTION = 3      <span class="xdoc">/*! Supersection (16 MB) */</span>
   330        };
   331    
   332        <span class="xdoc">/*!
</span>   333    <span class="xdoc">     *  Structure for setting first level descriptor entries
</span>   334    <span class="xdoc">     *
</span>   335    <span class="xdoc">     *  See the 'Memory Management Units' section of the device TRM for
</span>   336    <span class="xdoc">     *  more details.
</span>   337    <span class="xdoc">     */</span>
   338        <span class=key>struct</span> FirstLevelDescAttrs {
   339            FirstLevelDesc type;    <span class="xdoc">/*! first level descriptor type             */</span>
   340            Bool supersection;      <span class="xdoc">/*! is a supersection                       */</span>
   341        };
   342    
   343        <span class=comment>// Asserts</span>
   344    
   345        <span class="xdoc">/*!
</span>   346    <span class="xdoc">     *  ======== A_nullPointer ========
</span>   347    <span class="xdoc">     *  Assert raised when a pointer is null
</span>   348    <span class="xdoc">     */</span>
   349        <span class=key>config</span> Assert.Id A_nullPointer  = {
   350            msg: <span class="string">"A_nullPointer: Pointer is null"</span>
   351        };
   352    
   353        <span class="xdoc">/*!
</span>   354    <span class="xdoc">     *  ======== A_unknownDescType ========
</span>   355    <span class="xdoc">     *  Assert raised when the descriptor type is not recognized.
</span>   356    <span class="xdoc">     */</span>
   357        <span class=key>config</span> Assert.Id A_unknownDescType = {
   358            msg: <span class="string">"A_unknownDescType: Descriptor type is not recognized"</span>
   359        };
   360    
   361        <span class="xdoc">/*!
</span>   362    <span class="xdoc">     *  ======== A_baseValueOutOfRange ========
</span>   363    <span class="xdoc">     *  Assert raised when TLB lock entries base value out of range
</span>   364    <span class="xdoc">     */</span>
   365        <span class=key>config</span> Assert.Id A_baseValueOutOfRange  = {
   366            msg: <span class="string">"A_baseValueOutOfRange: TLB lock entries base value out of range"</span>
   367        };
   368    
   369        <span class="xdoc">/*! default descriptor attributes structure */</span>
   370        <span class=key>config</span> FirstLevelDescAttrs defaultAttrs = {
   371            type: FirstLevelDesc_SECTION,   <span class="comment">/* SECTION descriptor */</span>
   372            supersection: <span class=key>false</span>,            <span class="comment">/* false by default   */</span>
   373        };
   374    
   375        <span class="xdoc">/*!
</span>   376    <span class="xdoc">     *  ======== enableMMU ========
</span>   377    <span class="xdoc">     *  Configuration parameter to enable MMU.
</span>   378    <span class="xdoc">     */</span>
   379        <span class=key>config</span> Bool enableMMU = <span class=key>false</span>;
   380    
   381        <span class="xdoc">/*!
</span>   382    <span class="xdoc">     *  ======== baseAddr ========
</span>   383    <span class="xdoc">     *  MMU base address.
</span>   384    <span class="xdoc">     *
</span>   385    <span class="xdoc">     *  If not specified, will be automatically set at runtime.
</span>   386    <span class="xdoc">     */</span>
   387        <span class=key>config</span> Regs *baseAddr = <span class=key>null</span>;
   388    
   389        <span class="xdoc">/*!
</span>   390    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   391    <span class="xdoc">     *  MMU Registers.
</span>   392    <span class="xdoc">     */</span>
   393        <span class=key>struct</span> Regs {
   394            UInt32 REVISION;            <span class="xdoc">/*! 0x000 */</span>
   395            UInt32 hole1[3];            <span class="xdoc">/*! 0x004-0x00C */</span>
   396            UInt32 SYSCONFIG;           <span class="xdoc">/*! 0x010 */</span>
   397            UInt32 SYSSTATUS;           <span class="xdoc">/*! 0x014 */</span>
   398            UInt32 IRQSTATUS;           <span class="xdoc">/*! 0x018 */</span>
   399            UInt32 IRQENABLE;           <span class="xdoc">/*! 0x01C */</span>
   400            UInt32 hole2[8];            <span class="xdoc">/*! 0x020-0x03C */</span>
   401            UInt32 WALKING_ST;          <span class="xdoc">/*! 0x040 */</span>
   402            UInt32 CNTL;                <span class="xdoc">/*! 0x044 */</span>
   403            UInt32 FAULT_AD;            <span class="xdoc">/*! 0x048 */</span>
   404            UInt32 TTB;                 <span class="xdoc">/*! 0x04C */</span>
   405            UInt32 LOCK;                <span class="xdoc">/*! 0x050 */</span>
   406            UInt32 LD_TLB;              <span class="xdoc">/*! 0x054 */</span>
   407            UInt32 CAM;                 <span class="xdoc">/*! 0x058 */</span>
   408            UInt32 RAM;                 <span class="xdoc">/*! 0x05C */</span>
   409            UInt32 GFLUSH;              <span class="xdoc">/*! 0x060 */</span>
   410            UInt32 FLUSH_ENTRY;         <span class="xdoc">/*! 0x064 */</span>
   411            UInt32 READ_CAM;            <span class="xdoc">/*! 0x068 */</span>
   412            UInt32 READ_RAM;            <span class="xdoc">/*! 0x06C */</span>
   413            UInt32 EMU_FAULT_AD;        <span class="xdoc">/*! 0x070 */</span>
   414            UInt32 hole3[3];            <span class="xdoc">/*! 0x074-0x07C */</span>
   415            UInt32 FAULT_PC;            <span class="xdoc">/*! 0x080 */</span>
   416            UInt32 FAULT_STATUS;        <span class="xdoc">/*! 0x084 */</span>
   417            UInt32 GPR;                 <span class="xdoc">/*! 0x088 */</span>
   418            UInt32 BYPASS_REGION1_ADDR; <span class="xdoc">/*! 0x090 */</span>
   419            UInt32 BYPASS_REGION1_SIZE; <span class="xdoc">/*! 0x094 */</span>
   420            UInt32 BYPASS_REGION2_ADDR; <span class="xdoc">/*! 0x098 */</span>
   421            UInt32 BYPASS_REGION2_SIZE; <span class="xdoc">/*! 0x09C */</span>
   422            UInt32 BYPASS_REGION3_ADDR; <span class="xdoc">/*! 0x0A0 */</span>
   423            UInt32 BYPASS_REGION3_SIZE; <span class="xdoc">/*! 0x0A4 */</span>
   424            UInt32 BYPASS_REGION4_ADDR; <span class="xdoc">/*! 0x0A8 */</span>
   425            UInt32 BYPASS_REGION4_SIZE; <span class="xdoc">/*! 0x0AC */</span>
   426        };
   427    
   428        <span class="xdoc">/*!
</span>   429    <span class="xdoc">     *  ======== numTLBEntries ========
</span>   430    <span class="xdoc">     *  Number of TLB Cache entries.
</span>   431    <span class="xdoc">     */</span>
   432        <span class=key>config</span> UInt numTLBEntries = 32;
   433    
   434        <span class="xdoc">/*!
</span>   435    <span class="xdoc">     *  ======== setFirstLevelDescMeta ========
</span>   436    <span class="xdoc">     *  Statically sets the descriptor for the virtual address.
</span>   437    <span class="xdoc">     *
</span>   438    <span class="xdoc">     *  The first level table entry for the virtual address is mapped
</span>   439    <span class="xdoc">     *  to the physical address or points to the level 2 descriptor
</span>   440    <span class="xdoc">     *  table. The descriptor table is effective when the MMU is enabled.
</span>   441    <span class="xdoc">     *
</span>   442    <span class="xdoc">     *  <b>@param(virtualAddr)</b>  The modified virtual address
</span>   443    <span class="xdoc">     *  <b>@param(phyAddr)</b>      The physical address
</span>   444    <span class="xdoc">     *  <b>@param(attrs)</b>        Pointer to first level descriptor attribute struct
</span>   445    <span class="xdoc">     */</span>
   446        <span class=key>metaonly</span> Void setFirstLevelDescMeta(Ptr virtualAddr, Ptr phyAddr,
   447                                            FirstLevelDescAttrs attrs);
   448    
   449        <span class="xdoc">/*!
</span>   450    <span class="xdoc">     *  ======== disable ========
</span>   451    <span class="xdoc">     *  Disables the mmu.
</span>   452    <span class="xdoc">     *
</span>   453    <span class="xdoc">     *  If the MMU is already disabled, then simply return.
</span>   454    <span class="xdoc">     *  Otherwise this function does the following:
</span>   455    <span class="xdoc">     *  If the L1 data cache is enabled, write back invalidate all
</span>   456    <span class="xdoc">     *  of L1 data cache.  If the L1 program cache is enabled,
</span>   457    <span class="xdoc">     *  invalidate all of L1 program cache. This function does not
</span>   458    <span class="xdoc">     *  change the cache L1 data/program settings. If the L2 unified
</span>   459    <span class="xdoc">     *  cache is enabled, it is written back and invalidated.
</span>   460    <span class="xdoc">     *  This function also disables the table walking logic and
</span>   461    <span class="xdoc">     *  performs a global TLB flush. The global TLB flush does not
</span>   462    <span class="xdoc">     *  affect protected TLB entries.
</span>   463    <span class="xdoc">     *
</span>   464    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   465    <span class="xdoc">     *  The MMU hardware does not permit disabling the MMU
</span>   466    <span class="xdoc">     *  while an interrupt is pending. If this API is called with
</span>   467    <span class="xdoc">     *  an interrupt still pending, the MMU will generate an error.
</span>   468    <span class="xdoc">     */</span>
   469        Void disable();
   470    
   471        <span class="xdoc">/*!
</span>   472    <span class="xdoc">     *  ======== enable ========
</span>   473    <span class="xdoc">     *  Enables the MMU.
</span>   474    <span class="xdoc">     *
</span>   475    <span class="xdoc">     *  If the MMU is already enabled, then simply return.
</span>   476    <span class="xdoc">     *  Otherwise this function does the following:
</span>   477    <span class="xdoc">     *  If the L1 program cache is enabled, invalidate all of L1
</span>   478    <span class="xdoc">     *  program cache.  This function does not change the L1
</span>   479    <span class="xdoc">     *  data/program cache settings. If the L2 unified cache is
</span>   480    <span class="xdoc">     *  enabled, it is written back and invalidated.
</span>   481    <span class="xdoc">     *  This function also explicitly enables the table walking
</span>   482    <span class="xdoc">     *  logic and performs a global TLB flush. The global TLB
</span>   483    <span class="xdoc">     *  flush does not affect protected TLB entries.
</span>   484    <span class="xdoc">     */</span>
   485        Void enable();
   486    
   487        <span class="xdoc">/*!
</span>   488    <span class="xdoc">     *  ======== initDescAttrs() ========
</span>   489    <span class="xdoc">     *  Initializes the first level descriptor attribute structure
</span>   490    <span class="xdoc">     *
</span>   491    <span class="xdoc">     *  <b>@param(attrs)</b>      Pointer to first level descriptor attribute struct
</span>   492    <span class="xdoc">     */</span>
   493        Void initDescAttrs(FirstLevelDescAttrs *attrs);
   494    
   495        <span class="xdoc">/*!
</span>   496    <span class="xdoc">     *  ======== isEnabled ========
</span>   497    <span class="xdoc">     *  Determines if the MMU is enabled
</span>   498    <span class="xdoc">     */</span>
   499        Bool isEnabled();
   500    
   501        <span class="xdoc">/*!
</span>   502    <span class="xdoc">     *  ======== setFirstLevelDesc ========
</span>   503    <span class="xdoc">     *  Sets the descriptor for the virtual address.
</span>   504    <span class="xdoc">     *
</span>   505    <span class="xdoc">     *  The first level table entry for the virtual address is mapped
</span>   506    <span class="xdoc">     *  to the physical address with the attributes specified. The
</span>   507    <span class="xdoc">     *  descriptor table is effective when the MMU is enabled.
</span>   508    <span class="xdoc">     *
</span>   509    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   510    <span class="xdoc">     *  This API internally disables and re-enables the MMU.
</span>   511    <span class="xdoc">     *  Since the MMU hardware does not permit disabling the MMU
</span>   512    <span class="xdoc">     *  while an interrupt is pending, this API should not be called
</span>   513    <span class="xdoc">     *  with any interrupts still pending. It is recommended to
</span>   514    <span class="xdoc">     *  call this function from within main() before calling
</span>   515    <span class="xdoc">     *  BIOS_start().
</span>   516    <span class="xdoc">     *
</span>   517    <span class="xdoc">     *  <b>@param(virtualAddr)</b>  The modified virtual address
</span>   518    <span class="xdoc">     *  <b>@param(phyAddr)</b>      The physical address
</span>   519    <span class="xdoc">     *  <b>@param(attrs)</b>        Pointer to first level descriptor attribute struct
</span>   520    <span class="xdoc">     */</span>
   521        Void setFirstLevelDesc(Ptr virtualAddr, Ptr phyAddr,
   522                               FirstLevelDescAttrs *attrs);
   523    
   524        <span class="xdoc">/*!
</span>   525    <span class="xdoc">     *  ======== writeTLBEntry ========
</span>   526    <span class="xdoc">     *  Manually adds a TLB entry and locks it
</span>   527    <span class="xdoc">     *
</span>   528    <span class="xdoc">     *  This function ready the TLB lock base value and uses it to
</span>   529    <span class="xdoc">     *  select a victim TLB entry to write to. Once the new TLB
</span>   530    <span class="xdoc">     *  entry is written, it increments the TLB lock base value to
</span>   531    <span class="xdoc">     *  lock the entry. The TLB entries added using this function
</span>   532    <span class="xdoc">     *  are marked as protected and therefore are not affected by
</span>   533    <span class="xdoc">     *  global TLB flush operations.
</span>   534    <span class="xdoc">     *
</span>   535    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   536    <span class="xdoc">     *  Due to the mechanism used to lock TLB entries, it is
</span>   537    <span class="xdoc">     *  not possible to unlock a random locked TLB entry. All TLB
</span>   538    <span class="xdoc">     *  entries in front need to be unlocked first. For example,
</span>   539    <span class="xdoc">     *  if the first 4 TLB entries (i.e. TLB index 0, 1, 2 &amp; 3) are
</span>   540    <span class="xdoc">     *  locked and the second TLB entry (i.e. TLB index 1) needs to
</span>   541    <span class="xdoc">     *  be unlocked, then the TLB entries with indices 1, 2 &amp; 3
</span>   542    <span class="xdoc">     *  have to all be unlocked in order to unlock TLB entry
</span>   543    <span class="xdoc">     *  with index 1. This can be done by calling
</span>   544    <span class="xdoc">     *  {<b>@link</b> #setTLBLockBaseValue}() function.
</span>   545    <span class="xdoc">     *
</span>   546    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   547    <span class="xdoc">     *  This API internally disables and re-enables the MMU.
</span>   548    <span class="xdoc">     *  Since the MMU hardware does not permit disabling the MMU
</span>   549    <span class="xdoc">     *  while an interrupt is pending, this API should not be called
</span>   550    <span class="xdoc">     *  with any interrupts still pending. It is recommended to
</span>   551    <span class="xdoc">     *  call this function from within main() before calling
</span>   552    <span class="xdoc">     *  BIOS_start().
</span>   553    <span class="xdoc">     *
</span>   554    <span class="xdoc">     *  <b>@param(virtualAddr)</b>  The modified virtual address
</span>   555    <span class="xdoc">     *  <b>@param(phyAddr)</b>      The physical address
</span>   556    <span class="xdoc">     *  <b>@param(size)</b>         TLB page size.
</span>   557    <span class="xdoc">     *  <b>@b(returns)</b>          TRUE - Entry succesfully written and locked, OR,
</span>   558    <span class="xdoc">     *                       FALSE - Write failed. No free TLB entries.
</span>   559    <span class="xdoc">     */</span>
   560        Bool writeTLBEntry(Ptr virtualAddr, Ptr physicalAddr, PageSize size);
   561    
   562        <span class="xdoc">/*!
</span>   563    <span class="xdoc">     *  ======== clearTLBEntry ========
</span>   564    <span class="xdoc">     *  Clears (or flushes) a TLB entry
</span>   565    <span class="xdoc">     *
</span>   566    <span class="xdoc">     *  This function flushes all TLB entries (including protected
</span>   567    <span class="xdoc">     *  entries) pointed to by the given virtual address. It can be
</span>   568    <span class="xdoc">     *  used to delete a TLB entry after it has been unlocked.
</span>   569    <span class="xdoc">     *
</span>   570    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   571    <span class="xdoc">     *  This API internally disables and re-enables the MMU.
</span>   572    <span class="xdoc">     *  Since the MMU hardware does not permit disabling the MMU
</span>   573    <span class="xdoc">     *  while an interrupt is pending, this API should not be called
</span>   574    <span class="xdoc">     *  with any interrupts still pending.
</span>   575    <span class="xdoc">     *
</span>   576    <span class="xdoc">     *  <b>@param(virtualAddr)</b>  The modified virtual Address
</span>   577    <span class="xdoc">     */</span>
   578        Void clearTLBEntry(Ptr virtualAddr);
   579    
   580        <span class="xdoc">/*!
</span>   581    <span class="xdoc">     *  ======== setTLBLockBaseValue ========
</span>   582    <span class="xdoc">     *  Sets the TLB locked entries base value to the given value.
</span>   583    <span class="xdoc">     *
</span>   584    <span class="xdoc">     *  First n TLB entries (with n &lt; total number of TLB entries) can be
</span>   585    <span class="xdoc">     *  protected from being overwritten with new translations. n is equal
</span>   586    <span class="xdoc">     *  to the TLB locked entries base value.
</span>   587    <span class="xdoc">     *
</span>   588    <span class="xdoc">     *  This function can be used to unlock TLB entries. Once an
</span>   589    <span class="xdoc">     *  entry is unlocked, it can be cleared using {<b>@link</b> #clearTLBEntry}()
</span>   590    <span class="xdoc">     *  function.
</span>   591    <span class="xdoc">     *
</span>   592    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   593    <span class="xdoc">     *  This API internally disables and re-enables the MMU.
</span>   594    <span class="xdoc">     *  Since the MMU hardware does not permit disabling the MMU
</span>   595    <span class="xdoc">     *  while an interrupt is pending, this API should not be called
</span>   596    <span class="xdoc">     *  with any interrupts still pending.
</span>   597    <span class="xdoc">     *
</span>   598    <span class="xdoc">     *  <b>@param(basevalue)</b>    TLB locked entries base value
</span>   599    <span class="xdoc">     */</span>
   600        Void setTLBLockBaseValue(UInt basevalue);
   601    
   602    <span class=key>internal</span>:
   603    
   604        <span class="xdoc">/*! static array to hold first level dscriptor table */</span>
   605        <span class=key>metaonly</span> <span class=key>config</span> UInt32 tableBuf[];
   606    
   607        <span class="xdoc">/*!
</span>   608    <span class="xdoc">     *  ======== init ========
</span>   609    <span class="xdoc">     *  initialize mmu registers
</span>   610    <span class="xdoc">     */</span>
   611        Void init();
   612    
   613        <span class="xdoc">/*! function generated to initialize first level descriptor table */</span>
   614        Void initTableBuf(UInt32 *mmuTableBuf);
   615    
   616        <span class="xdoc">/*! Module state */</span>
   617        <span class=key>struct</span> Module_State {
   618            volatile Regs *regs;
   619            UInt32        tableBuf[];  <span class="xdoc">/*! 16KB array for first-level descriptors */</span>
   620        }
   621    }
</pre>
</body></html>
