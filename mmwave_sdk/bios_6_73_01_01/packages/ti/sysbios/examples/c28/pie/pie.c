/* 
 *  28x specific PIE example.
 *  
 *  This example demonstrates how to handle peripheral interrupts which come
 *  from the 28x PIE.  In this example, the interrupts are simulated, however in
 *  a real world application the interrupts would be generated by the
 *  actual peripherals themselves. 
 * 
 *  1) The configuration file maps several PIE interrupts to the ISR function
 *     'myIsr'.  Configuring these interrupts like this also causes them to be
 *     enabled. 
 * 
 *  2) The configuration file also creates a task 'myTaskFxn' which simulates
 *     the peripheral interrupts by calling PIE_post().  PIE_post() directly
 *     writes to the PIEIFR register to flag the actual PIE interrupt.
 *
 *  3) Once the PIE interrupt is flagged, and since the same interrupt is
 *     enabled, the corresponding interrupt vector 'myIsr' is run.
 * 
 *  4) 'myIsr' prints out the argument that was configured for the PIE
 *     interrupt that's currently running.
 * 
 *  All output is routed to a log buffer which can be viewed
 *  using the RTA "Raw Logs" viewer. After loading and running
 *  the application, launch the Tools->RTA->Raw Logs tool to
 *  view the logs.
 */
#include <xdc/std.h>
#include <xdc/runtime/Log.h>
#include <ti/sysbios/BIOS.h>

#include <ti/sysbios/knl/Task.h>

#include <ti/sysbios/family/c28/Hwi.h>

#define PIECTRL_ADDR            0x000CE0
#define PIEIFR1_ADDR            0x000CE3
#define PIEIER1_ADDR            0x000CE2

/*
 *  ======== PIE_post ========
 *  This function is used to manually trigger a PIE interrupt by writing
 *  directly to the PIEIFR register.
 *
 *  Calling this function will simulate the triggering of a peripheral
 *  interrupt.  In a real world app, this function would not be needed as the
 *  interrupt would be triggered automatically by the hardware peripheral
 *  itself.
 */
Void PIE_post(Uns intNum)
{
    Bits16 *PIEIFRPtr;

    /* Flag PIE IFR */
    PIEIFRPtr = (Bits16 *)PIEIER1_ADDR + (((intNum -
            ti_sysbios_family_c28_Hwi_NUM_INTERRUPTS) >> 3) * 2) + 1;
    *PIEIFRPtr |= (1 << (intNum & 0x7));
}

/*
 *  ======== myIsr ========
 *  Interrupt service routine for the PIE interrupts.
 */
Void myIsr(UArg arg)
{
    Log_info1("Executing in myIsr for interrupt #%d.\n", arg);
}

/*
 *  ======== myTaskFxn ========
 *  Task function which calls PIE_post() to simulate peripheral interrupts.
 *
 *  The PIE group/interrupt number mappings used below were determined using
 *  the "PIE MUXed Peripheral Interrupt Vector Table", which can be found in
 *  the SYS/BIOS API documentation for the ti.sysbios.family.c28.Hwi module.
 */
Void myTaskFxn()
{
    /* post PIE group 1, interrupt 1 */
    Log_info0("Posting PIE group 1, interrupt 32.\n");
    PIE_post(32);

    /* post PIE group 1, interrupt 5 */
    Log_info0("Posting PIE group 1, interrupt 5.\n");
    PIE_post(36);
}

/*
 *  ======== main ========
 */
Int main(Int argc, Char* argv[])
{
    BIOS_start();
    return(0);
}
