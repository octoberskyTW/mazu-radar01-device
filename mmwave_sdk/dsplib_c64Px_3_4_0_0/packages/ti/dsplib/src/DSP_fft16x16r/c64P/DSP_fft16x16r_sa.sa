* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSP_fft16x16r_sa -- DSP_fft16x16r                                   *
*                                                                          *
*  USAGE                                                                   * 
*                                                                          * 
*      void fft16x16r(                                                     * 
*          int N, short * ptr_x, const short * ptr_w, unsigned char brev   *
*          short * ptr_y, int n_min, int offset, int n_max);               * 
*                                                                          * 
*      N      = length of fft in complex samples, power of 2 <=16384       * 
*      ptr_x  = pointer to complex data input                              * 
*      ptr_w  = pointer to complex twiddle factor (see below)              * 
*      brev   = pointer to bit reverse table containing 64 entries         * 
*      n_min  = smallest fft butterfly used in computation                 * 
*               used for decomposing fft into subffts, see notes           * 
*      offset = index in complex samples of sub-fft from start of main f   * 
*      n_max  = size of main fft in complex samples                        * 
*                                                                          * 
*      (See the C compiler reference guide.)                               * 
*                                                                          * 
*   DESCRIPTION                                                            * 
*      The benchmark performs a mixed radix forwards fft using             * 
*      a special sequence of coefficients generated in the following       * 
*      way:                                                                * 
*                                                                          * 
*        -* generate vector of twiddle factors for optimized algorithm *-  * 
*       void tw_gen(short * w, int N)                                      * 
*       {                                                                  * 
*         int j, k;                                                        * 
*         double x_t, y_t, theta1, theta2, theta3;                         * 
*         const double PI = 3.141592654, M = 32767.0;                      * 
*                                      -* M is 16383 for scale by 4 *-     * 
*                                                                          * 
*         for (j=1, k=0; j <= N>>2; j = j<<2)                              * 
*         {                                                                * 
*             for (i=0; i < N>>2; i+=j)                                    * 
*             {                                                            * 
*                 theta1 = 2*PI*i/N;                                       * 
*                 x_t = M*cos(theta1);                                     * 
*                 y_t = M*sin(theta1);                                     * 
*                 w[k]   =  (short)x_t;                                    * 
*                 w[k+1] =  (short)y_t;                                    * 
*                                                                          * 
*                 theta2 = 4*PI*i/N;                                       * 
*                 x_t = M*cos(theta2);                                     * 
*                 y_t = M*sin(theta2);                                     * 
*                 w[k+2] =  (short)x_t;                                    * 
*                 w[k+3] =  (short)y_t;                                    * 
*                                                                          * 
*                 theta3 = 6*PI*i/N;                                       * 
*                 x_t = M*cos(theta3);                                     * 
*                 y_t = M*sin(theta3);                                     * 
*                 w[k+4] =  (short)x_t;                                    * 
*                 w[k+5] =  (short)y_t;                                    * 
*                 k+=6;                                                    * 
*             }                                                            * 
*         }                                                                * 
*       }                                                                  * 
*      This redundent set of twiddle factors is size 2*N short samples.    * 
*      As pointed out later dividing these twiddle factors by 2 will give  * 
*      an effective divide by 4 at each stage to guarentee no overflow.    * 
*      The function is accurate to about 68dB of signal to noise ratio     * 
*      to the DFT function below:                                          * 
*                                                                          * 
*       void dft(int n, short x[], short y[])                              * 
*       {                                                                  * 
*          int k,i, index;                                                 * 
*          const double PI = 3.14159654;                                   * 
*          short * p_x;                                                    * 
*          double arg, fx_0, fx_1, fy_0, fy_1, co, si;                     * 
*                                                                          * 
*          for(k = 0; k<n; k++)                                            * 
*          {                                                               * 
*            p_x = x;                                                      * 
*            fy_0 = 0;                                                     * 
*            fy_1 = 0;                                                     * 
*            for(i=0; i<n; i++)                                            * 
*            {                                                             * 
*              fx_0 = (double)p_x[0];                                      * 
*              fx_1 = (double)p_x[1];                                      * 
*              p_x += 2;                                                   * 
*              index = (i*k) % n;                                          * 
*              arg = 2*PI*index/n;                                         * 
*              co = cos(arg);                                              * 
*              si = -sin(arg);                                             * 
*              fy_0 += ((fx_0 * co) - (fx_1 * si));                        * 
*              fy_1 += ((fx_1 * co) + (fx_0 * si));                        * 
*            }                                                             * 
*            y[2*k] = (short)2*fy_0/sqrt(N);                               * 
*            y[2*k+1] = (short)2*fy_1/sqrt(N);                             * 
*          }                                                               * 
*       }                                                                  * 
*      Scaling takes place at each stage except the last one.              * 
*      This is a divide by 2 to prevent overflow. All shifts are rounded   * 
*      reduce truncation noise power by 3dB.                               * 
*      The function takes the table and input data and calculates the fft  * 
*      producing the frequency domain data in the Y array.                 * 
*      As the fft allows every input point to effect every output point i  * 
*      a cache based system such as the c64xx, this causes cache thrashin  * 
*      This is mitigated by allowing the main fft of size N to be divided  * 
*      into several steps, allowing as much data reuse as possible.        * 
*                                                                          * 
*      For example the following function:                                 * 
*                                                                          * 
*      fft16x16r  (1024, &x_asm[0],&w[0],y_asm,brev,4,  0,1024);           * 
*                                                                          * 
*      is equvalent to:                                                    * 
*                                                                          * 
*      fft16x16r  (1024,&x_asm[2*0],  &w[0]    ,y_asm,brev,256,  0,1024);  * 
*      fft16x16r  (256, &x_asm[2*0],  &w[2*768],y_asm,brev,4,    0,1024);  * 
*      fft16x16r  (256, &x_asm[2*256],&w[2*768],y_asm,brev,4,  256,1024);  * 
*      fft16x16r  (256, &x_asm[2*512],&w[2*768],y_asm,brev,4,  512,1024);  * 
*      fft16x16r  (256, &x_asm[2*768],&w[2*768],y_asm,brev,4,  768,1024);  * 
*                                                                          * 
*      Notice how the 1st fft function is called on the entire 1K data se  * 
*      it covers the 1st pass of the fft until the butterfly size is 256.  * 
*      The following 4 ffts do 256 pt ffts 25% of the size. These continu  * 
*      down to the end when the buttefly is of size 4. The use an index t  * 
*      the main twiddle factor array of 0.75*2*N. This is because the      * 
*      twiddle factor array is composed of successively decimated version  * 
*      of the main array.                                                  * 
*                                                                          * 
*      N not equal to a power of 4 can be used, i.e. 512. In this case to  * 
*      decompose the fft the following would be needed :                   * 
*                                                                          * 
*      fft16x16r   (512, &x_asm[0],&w[0],y_asm,brev,2,  0,512);            * 
*                                                                          * 
*      is equvalent to:                                                    * 
*                                                                          * 
*      fft16x16r   (512, &x_asm[0],    &w[0],    y_asm,brev,128,  0,512);  * 
*      fft16x16r   (128, &x_asm[2*0],  &w[2*384],y_asm,brev,2,    0,512);  * 
*      fft16x16r   (128, &x_asm[2*128],&w[2*384],y_asm,brev,2,  128,512);  * 
*      fft16x16r   (128, &x_asm[2*256],&w[2*384],y_asm,brev,2,  256,512);  * 
*      fft16x16r   (128, &x_asm[2*384],&w[2*384],y_asm,brev,2,  384,512);  * 
*                                                                          * 
*      The twiddle factor array is composed of log4(N) sets of twiddle     * 
*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     * 
*      array for each stage of the fft is calculated by summing these      * 
*      indices up appropriately.                                           * 
*      For multiple ffts they can share the same table by calling the sma  * 
*      ffts from further down in the twiddle factor array. In the same wa  * 
*      as the decomposition works for more data reuse.                     * 
*                                                                          * 
*      Thus, the above decomposition can be summarized for a general N ,   * 
*      radix "rad" as follows:                                             * 
*                                                                          * 
*  fft16x16r(N,  &x_cn[0],         &w[0],        brev, y_cn, N/4, 0,     N * 
*  fft16x16r(N/4,&x_cn[0],         &w[2*(3*N/4)],brev, y_cn, rad, 0,     N * 
*  fft16x16r(N/4,&x_cn[2*(N/4)],   &w[2*(3*N/4)],brev, y_cn, rad, N/4,   N * 
*  fft16x16r(N/4,&x_cn[2*(N/2)],   &w[2*(3*N/4)],brev, y_cn, rad, N/2,   N * 
*  fft16x16r(N/4,&x_cn[2*(3*N/4)], &w[2*3*N/4)], brev, y_cn, rad, 3*N/4, N * 
*                                                                          * 
*      As discussed previously, N can be either a power of 4 or 2.  If  N  * 
*      N is a power  of 4, rad = 4, and if N is a power of 2, and not  a   * 
*      power of 4, then rad = 2. "rad" is used to control how many stages  * 
*      of decomposition are performed. It is also used to dtermine whethe  * 
*      a radix4 or radix2 decomposition should be performed at the last    * 
*      stage. Hence when "rad" is set to "N/4" the first stage of the      * 
*      transform alone is performed and the code exits. To complete the    * 
*      FFT four other calls are required to perform N/4 size FFT's. In     * 
*      fact the ordering of these 4 FFT's amonst themselves does not       * 
*      matter and hence from a cahe perspective it helps to go through     * 
*      the remaining 4 FFT's in exactly the opposite order to the first.   * 
*                                                                          * 
*      This is illustrated as follows:                                     * 
*                                                                          * 
*  fft16x16r(N,  &x_cn[0],         &w[0],        brev, y_cn, N/4, 0,     N * 
*  fft16x16r(N/4,&x_cn[2*(3*N/4)], &w[2*3*N/4)], brev, y_cn, rad, 3*N/4, N * 
*  fft16x16r(N/4,&x_cn[2*(N/2)],   &w[2*(3*N/4)],brev, y_cn, rad, N/2,   N * 
*  fft16x16r(N/4,&x_cn[2*(N/4)],   &w[2*(3*N/4)],brev, y_cn, rad, N/4,   N * 
*  fft16x16r(N/4,&x_cn[0],         &w[2*(3*N/4)],brev, y_cn, rad, 0,     N * 
*                                                                          * 
*      In addition this function can be used to minimize call overhead, b  * 
*      completing the FFT with one function call invocation as shown belo  * 
*                                                                          * 
*      fft16x16r(N, &x_cn[0], &w[0], y_cn, brev, rad, 0, N)                * 
*                                                                          * 
*  ASSUMPTIONS:                                                            * 
*      n must be a power of 2 and n >= 8  n <= 16384 points.               * 
*      Complex time data x and twiddle facotrs w are aligned on double     * 
*      word boundares. Real values are stored in even word positions and   * 
*      imaginary values in odd positions.                                  * 
*                                                                          * 
*      All data is in short precision integer fixed point form. The        * 
*      complex frequency data will be returned in linear order.            * 
*                                                                          * 
*                                                                          * 
*  MEMORY NOTE:                                                            * 
*      Configuration is LITTLE ENDIAN the code will not function if the -  * 
*      flag is enabled but it can be modified for BIG ENDIAN usage.        * 
*                                                                          * 
*  TECHNIQUES                                                              * 
*      A special sequence of coeffs. used as generated above               * 
*      produces the fft. This collapses the inner 2 loops in the           * 
*      taditional Burrus and Parks implementation Fortran Code.            * 
*                                                                          * 
*      The revised FFT uses a redundant sequence of twiddle factors to     * 
*      allow a linear access through the data. This linear access enables  * 
*      data and instruction level parallelism.                             * 
*      The data produced by the fft16x16r fft is in normal form, the       * 
*      whole data array is written into a new output buffer.               * 
*                                                                          * 
*      The fft16x16r butterfly is bit reversed, i.e. the inner 2 points o  * 
*      the butterfly are corssed over, this has the effect of making the   * 
*      data come out in bit reversed rather than in radix 4 digit reverse  * 
*      order. This simplifies the last pass of the loop. It is performed   * 
*      using the _bitr instruction on C64x architecture. It is performed   * 
*      using a macro BIT_REV instead.                                      * 
*                                                                          * 
*  NOTES                                                                   * 
*      For more aggressive overflow control the shift in the DC term can   * 
*      adjusted to 2 and the twiddle factors shifted right by 1. This giv  * 
*      a divide by 4 at each stage. For better accuracy the data can be p  * 
*      asserted left by so many bits so that as it builds in magnitude th  * 
*      divide by 2 prevents too much growth. An optimal point for example  * 
*      with an 8192pt fft with input data precision of 8 bits is to asert  * 
*      the input 4 bits left to make it 12 bits. This gives an SNR of 68d  * 
*      at the output. By trying combinations the optimal can be found.     * 
*      If scaling isnot required it is possible to replace the MPY by SMP  * 
*      this will give a shift left by 1 so a shift right by 16 gives a     * 
*      total 15 bit shift right. The DC term must be adjusted to give a    * 
*      zero shift.                                                         * 
*                                                                          * 
*  C CODE                                                                  * 
*      The following code is the traditional Burrus and Parks implemen-    * 
*      tation, which performs a mixed radix FFT capable of 2^M, 4^M.       * 
*      However it does not support multiple calls. It uses a traditional   * 
*      twiddle factor array wn, generated as follows:                      * 
*                                                                          * 
*      const double M = 32767.0;                                           * 
*      const double PI = 3.141592654;                                      * 
*                                                                          * 
*      for (i=0, k = 0; i < 3*(N>>2); i++)                                 * 
*      {                                                                   * 
*         theta1 = 2*PI*i/N;                                               * 
*         x_t = M*cos(theta1);                                             * 
*         y_t = M*sin(theta1);                                             * 
*         wn[k]   = (short) x_t;                                           * 
*         if (x_t >= M) wn[k  ] = 0x7fff;                                  * 
*         wn[k+1] = (short) y_t;                                           * 
*         if (y_t >= M) wn[k+1] = 0x7fff;                                  * 
*         k+=2;                                                            * 
*      }                                                                   * 
*                                                                          * 
*      The C code that implements the traditional mixed radix FFT is       * 
*      shown below. It has three nested loops, one for the stages,         * 
*      one for the groups of butterflies, one for the passes.              * 
*                                                                          * 
*  void fft16x16r_cn(int n, short x[], short wn[],                         * 
*        unsigned char brev[], short y[], int radix, int offset, int nmax) * 
*  {                                                                       * 
*      int    n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, i, l0;            * 
*      short  co1, co2, co3, si1, si2, si3;                                * 
*      short  xt0, yt0, xt1, yt1, xt2, yt2;                                * 
*      short  xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                         * 
*      short * ptr_x0, * y0;                                               * 
*      unsigned int  j0, j1, k0, k1, k, j;                                 * 
*      short x0, x1, x2, x3, x4, x5, x6, x7;                               * 
*      short xh0_0, xh1_0, xh0_1, xh1_1;                                   * 
*      short xl0_0, xl1_0, xl0_1, xl1_1;                                   * 
*      short yt3, yt4, yt5, yt6, yt7;                                      * 
*                                                                          * 
*      n2 = n;                                                             * 
*      ie = 1;                                                             * 
*      for (k = n; k > radix; k >>= 2)                                     * 
*      {                                                                   * 
*          n1 = n2;                                                        * 
*          n2 >>= 2;                                                       * 
*          ia1 = 0;                                                        * 
*          for (j = 0; j < n2; j++)                                        * 
*          {                                                               * 
*              ia2 = ia1 + ia1;                                            * 
*              ia3 = ia2 + ia1;                                            * 
*              co1 = w[2 * ia1    ];                                       * 
*              si1 = w[2 * ia1 + 1];                                       * 
*              co2 = w[2 * ia2    ];                                       * 
*              si2 = w[2 * ia2 + 1];                                       * 
*              co3 = w[2 * ia3    ];                                       * 
*              si3 = w[2 * ia3 + 1];                                       * 
*              ia1 = ia1 + ie;                                             * 
*              for (i0 = j; i0 < n; i0 += n1)                              * 
*              {                                                           * 
*                  i1 = i0 + n2;                                           * 
*                  i2 = i1 + n2;                                           * 
*                  i3 = i2 + n2;                                           * 
*                                                                          * 
*                  xh0  = x[2 * i0    ] + x[2 * i2    ];                   * 
*                  xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];                   * 
*                  xl0  = x[2 * i0    ] - x[2 * i2    ];                   * 
*                  xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];                   * 
*                                                                          * 
*                  xh20 = x[2 * i1    ] + x[2 * i3    ];                   * 
*                  xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];                   * 
*                  xl20 = x[2 * i1    ] - x[2 * i3    ];                   * 
*                  xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];                   * 
*                                                                          * 
*                  x[2 * i0    ] = (xh0 + xh20 + 1)>>1;                    * 
*                  x[2 * i0 + 1] = (xh1 + xh21 + 1)>>1;                    * 
*                                                                          * 
*                  xt0  = xh0 - xh20;                                      * 
*                  yt0  = xh1 - xh21;                                      * 
*                  xt1  = xl0 + xl21;                                      * 
*                  yt2  = xl1 + xl20;                                      * 
*                  xt2  = xl0 - xl21;                                      * 
*                  yt1  = xl1 - xl20;                                      * 
*                                                                          * 
*                  x[2 * i2    ]= (xt1 * co1 + yt1 * si1 + 0x00008000)>> 16* 
*                  x[2 * i2 + 1]= (yt1 * co1 - xt1 * si1 + 0x00008000)>> 16* 
*                  x[2 * i1    ]= (xt0 * co2 + yt0 * si2 + 0x00008000)>> 16* 
*                  x[2 * i1 + 1]= (yt0 * co2 - xt0 * si2 + 0x00008000)>> 16* 
*                  x[2 * i3    ]= (xt2 * co3 + yt2 * si3 + 0x00008000)>> 16* 
*                  x[2 * i3 + 1]= (yt2 * co3 - xt2 * si3 + 0x00008000)>> 16* 
*              }                                                           * 
*          }                                                               * 
*                                                                          * 
*          ie <<= 2;                                                       * 
*      }                                                                   * 
*                                                                          * 
*      j = 0;                                                              * 
*      ptr_x0 = x;                                                         * 
*      y0 = y;                                                             * 
*      l0 = _norm(n) - 17;                                                 * 
*                                                                          * 
*      if(radix == 2 || radix  == 4) for (i = 0; i < n; i += 4)            * 
*      {                                                                   * 
*          j0 = (j     ) & 0x3F;                                           * 
*          j1 = (j >> 6) & 0x3F;                                           * 
*          k0 = brev[j0];                                                  * 
*          k1 = brev[j1];                                                  * 
*          k = (k0 << 6) |  k1;                                            * 
*          if (l0 < 0) k = k << -l0;                                       * 
*          else        k = k >> l0;                                        * 
*          j++;                                                            * 
*                                                                          * 
*          x0   = ptr_x0[0];  x1 = ptr_x0[1];                              * 
*          x2   = ptr_x0[2];  x3 = ptr_x0[3];                              * 
*          x4   = ptr_x0[4];  x5 = ptr_x0[5];                              * 
*          x6   = ptr_x0[6];  x7 = ptr_x0[7];                              * 
*          ptr_x0 += 8;                                                    * 
*                                                                          * 
*          xh0_0  = x0 + x4;                                               * 
*          xh1_0  = x1 + x5;                                               * 
*          xh0_1  = x2 + x6;                                               * 
*          xh1_1  = x3 + x7;                                               * 
*                                                                          * 
*          if (radix == 2)                                                 * 
*          {                                                               * 
*              xh0_0 = x0;                                                 * 
*              xh1_0 = x1;                                                 * 
*              xh0_1 = x2;                                                 * 
*              xh1_1 = x3;                                                 * 
*          }                                                               * 
*                                                                          * 
*          yt0  = xh0_0 + xh0_1;                                           * 
*          yt1  = xh1_0 + xh1_1;                                           * 
*          yt4  = xh0_0 - xh0_1;                                           * 
*          yt5  = xh1_0 - xh1_1;                                           * 
*                                                                          * 
*          xl0_0  = x0 - x4;                                               * 
*          xl1_0  = x1 - x5;                                               * 
*          xl0_1  = x2 - x6;                                               * 
*          xl1_1  = x3 - x7;                                               * 
*                                                                          * 
*          if (radix == 2)                                                 * 
*          {                                                               * 
*                  xl0_0 = x4;                                             * 
*                  xl1_0 = x5;                                             * 
*                  xl1_1 = x6;                                             * 
*                  xl0_1 = x7;                                             * 
*          }                                                               * 
*                                                                          * 
*          yt2  = xl0_0 + xl1_1;                                           * 
*          yt3  = xl1_0 - xl0_1;                                           * 
*                                                                          * 
*          yt6  = xl0_0 - xl1_1;                                           * 
*          yt7  = xl1_0 + xl0_1;                                           * 
*                                                                          * 
*          if (radix == 2)                                                 * 
*          {                                                               * 
*                  yt7  = xl1_0 - xl0_1;                                   * 
*                  yt3  = xl1_0 + xl0_1;                                   * 
*          }                                                               * 
*                                                                          * 
*          y0[k] = yt0; y0[k+1] = yt1;                                     * 
*          k += n>>1                                                       * 
*          y0[k] = yt2; y0[k+1] = yt3;                                     * 
*          k += n>>1;                                                      * 
*          y0[k] = yt4; y0[k+1] = yt5;                                     * 
*          k += n>>1;                                                      * 
*          y0[k] = yt6; y0[k+1] = yt7;                                     * 
*      }                                                                   * 
*  }                                                                       * 
*                                                                          * 
*      Although code shown above is the simplest equivalent way of writin  * 
*      this code, it already carries several optimization ideas. It has    * 
*      a special last stage to avoid multiplication by 1. In addition it   * 
*      was shown by Panos Papamichalis that if the two middle legs of a    * 
*      radix 4 butterfly are reversed, the outputs for a radix4 transform  * 
*      end up in the bit reversed fashion. The code also carries a linear  * 
*      time look up table for bit reversal. This can be used as shown in   * 
*      the code to construct a bit reversed index. The last stage perfo-   * 
*      rms either a radix4 or radix2 as the case may be.                   * 
*                                                                          * 
*      The code shown below performs loop coalescing as it is realized     * 
*      that while the "i" and "j" loop individually iterate for variable   * 
*      number of times, together they always iterate for N/4 times. The    * 
*      natural C code and the code shown below use a modified twiddle      * 
*      factor array to allow for vectorization of the loop. In addition    * 
*      bit-reversal is performed by a macro BIT_REV. This makes the bit-   * 
*      reversal table redundant.                                           * 
*                                                                          * 
*      This is the C equivalent of the assembly code without restrictions  * 
*      Note that the assembly code is hand optimized and restrictions may  * 
*      apply.                                                              * 
*                                                                          * 
*                                                                          * 
*      void fft16x16r_co(int n, short ptr_x[], short ptr_w[], short ptr_y[ * 
*                    unsigned char brev[], int n_min, int offset, int n_max* 
*      {                                                                   * 
*          int  i, j, k, l1, l2, h2, predj;                                * 
*          int  tw_offset, stride, fft_jmp;                                * 
*                                                                          * 
*          short x0, x1, x2, x3,x4,x5,x6,x7;                               * 
*          short xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        * 
*          short yt4, yt5, yt6, yt7;                                       * 
*          short si1,si2,si3,co1,co2,co3;                                  * 
*          short xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      * 
*          short x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      * 
*          short xl0_0, xl1_0, xl0_1, xl1_1;                               * 
*          short xh0_0, xh1_0, xh0_1, xh1_1;                               * 
*          short *x,*w;                                                    * 
*          int   k0, k1, j0, j1, l0, radix;                                * 
*          short * y0, * ptr_x0, * ptr_x2;                                 * 
*                                                                          * 
*          radix = n_min;                                                  * 
*                                                                          * 
*          stride = n; -* n is the number of complex samples *-            * 
*          tw_offset = 0;                                                  * 
*          while (stride > radix)                                          * 
*          {                                                               * 
*              j = 0;                                                      * 
*              fft_jmp = stride + (stride>>1);                             * 
*              h2 = stride>>1;                                             * 
*              l1 = stride;                                                * 
*              l2 = stride + (stride>>1);                                  * 
*              x = ptr_x;                                                  * 
*              w = ptr_w + tw_offset;                                      * 
*                                                                          * 
*              for (i = 0; i < n; i += 4)                                  * 
*              {                                                           * 
*                  co1 = w[j];                                             * 
*                  si1 = w[j+1];                                           * 
*                  co2 = w[j+2];                                           * 
*                  si2 = w[j+3];                                           * 
*                  co3 = w[j+4];                                           * 
*                  si3 = w[j+5];                                           * 
*                                                                          * 
*                  x_0    = x[0];                                          * 
*                  x_1    = x[1];                                          * 
*                  x_h2   = x[h2];                                         * 
*                  x_h2p1 = x[h2+1];                                       * 
*                  x_l1   = x[l1];                                         * 
*                  x_l1p1 = x[l1+1];                                       * 
*                  x_l2   = x[l2];                                         * 
*                  x_l2p1 = x[l2+1];                                       * 
*                                                                          * 
*                  xh0  = x_0    + x_l1;                                   * 
*                  xh1  = x_1    + x_l1p1;                                 * 
*                  xl0  = x_0    - x_l1;                                   * 
*                  xl1  = x_1    - x_l1p1;                                 * 
*                                                                          * 
*                  xh20 = x_h2   + x_l2;                                   * 
*                  xh21 = x_h2p1 + x_l2p1;                                 * 
*                  xl20 = x_h2   - x_l2;                                   * 
*                  xl21 = x_h2p1 - x_l2p1;                                 * 
*                                                                          * 
*                  ptr_x0 = x;                                             * 
*                  ptr_x0[0] = ((short) (xh0 + xh20))>>1; can be changed to* 
*                  ptr_x0[1] = ((short) (xh1 + xh21))>>1; can be changed to* 
*                                                                          * 
*                  ptr_x2 = ptr_x0;                                        * 
*                  x += 2;                                                 * 
*                  j += 6;                                                 * 
*                  predj = (j - fft_jmp);                                  * 
*                  if (!predj) x += fft_jmp;                               * 
*                  if (!predj) j = 0;                                      * 
*                                                                          * 
*                  xt0 = xh0 - xh20;                                       * 
*                  yt0 = xh1 - xh21;                                       * 
*                  xt1 = xl0 + xl21;                                       * 
*                  yt2 = xl1 + xl20;                                       * 
*                  xt2 = xl0 - xl21;                                       * 
*                  yt1 = xl1 - xl20;                                       * 
*                                                                          * 
*                  ptr_x2[l1  ] = (xt1 * co1 + yt1 * si1 + 0x8000)>>16;    * 
*                  ptr_x2[l1+1] = (yt1 * co1 - xt1 * si1 + 0x8000)>>16;    * 
*                  ptr_x2[h2  ] = (xt0 * co2 + yt0 * si2 + 0x8000)>>16;    * 
*                  ptr_x2[h2+1] = (yt0 * co2 - xt0 * si2 + 0x8000)>>16;    * 
*                  ptr_x2[l2  ] = (xt2 * co3 + yt2 * si3 + 0x8000)>>16;    * 
*                  ptr_x2[l2+1] = (yt2 * co3 - xt2 * si3 + 0x8000)>>16;    * 
*              }                                                           * 
*              tw_offset += fft_jmp;                                       * 
*              stride = stride>>2;                                         * 
*          }-* end while *-                                                * 
*                                                                          * 
*          j = offset>>2;                                                  * 
*                                                                          * 
*          ptr_x0 = ptr_x;                                                 * 
*          y0 = ptr_y;                                                     * 
*          l0 = _norm(nmax) - 17; -* get size of fft *-                    * 
*                                                                          * 
*          if (radix <= 4) for (i = 0; i < n; i += 4)                      * 
*          {                                                               * 
*                  -* reversal computation *-                              * 
*                                                                          * 
*                  j0 = (j     ) & 0x3F;                                   * 
*                  j1 = (j >> 6) & 0x3F;                                   * 
*                  k0 = brev[j0];                                          * 
*                  k1 = brev[j1];                                          * 
*                  k = (k0 << 6) |  k1;                                    * 
*                  k = k >> l0;                                            * 
*                  j++;        -* multiple of 4 index *-                   * 
*                                                                          * 
*                  x0   = ptr_x0[0];  x1 = ptr_x0[1];                      * 
*                  x2   = ptr_x0[2];  x3 = ptr_x0[3];                      * 
*                  x4   = ptr_x0[4];  x5 = ptr_x0[5];                      * 
*                  x6   = ptr_x0[6];  x7 = ptr_x0[7];                      * 
*                  ptr_x0 += 8;                                            * 
*                                                                          * 
*                  xh0_0  = x0 + x4;                                       * 
*                  xh1_0  = x1 + x5;                                       * 
*                  xh0_1  = x2 + x6;                                       * 
*                  xh1_1  = x3 + x7;                                       * 
*                                                                          * 
*                  if (radix == 2) {                                       * 
*                    xh0_0 = x0;                                           * 
*                    xh1_0 = x1;                                           * 
*                    xh0_1 = x2;                                           * 
*                    xh1_1 = x3;                                           * 
*                  }                                                       * 
*                                                                          * 
*                  yt0  = xh0_0 + xh0_1;                                   * 
*                  yt1  = xh1_0 + xh1_1;                                   * 
*                  yt4  = xh0_0 - xh0_1;                                   * 
*                  yt5  = xh1_0 - xh1_1;                                   * 
*                                                                          * 
*                  xl0_0  = x0 - x4;                                       * 
*                  xl1_0  = x1 - x5;                                       * 
*                  xl0_1  = x2 - x6;                                       * 
*                  xl1_1  = x3 - x7;                                       * 
*                                                                          * 
*                  if (radix == 2) {                                       * 
*                    xl0_0 = x4;                                           * 
*                    xl1_0 = x5;                                           * 
*                    xl1_1 = x6;                                           * 
*                    xl0_1 = x7;                                           * 
*                  }                                                       * 
*                                                                          * 
*                  yt2  = xl0_0 + xl1_1;                                   * 
*                  yt3  = xl1_0 - xl0_1;                                   * 
*                  yt6  = xl0_0 - xl1_1;                                   * 
*                  yt7  = xl1_0 + xl0_1;                                   * 
*                                                                          * 
*                  if (radix == 2) {                                       * 
*                    yt7  = xl1_0 - xl0_1;                                 * 
*                    yt3  = xl1_0 + xl0_1;                                 * 
*                  }                                                       * 
*                                                                          * 
*                  y0[k] = yt0; y0[k+1] = yt1;                             * 
*                  k += n>>1;                                              * 
*                  y0[k] = yt2; y0[k+1] = yt3;                             * 
*                  k += n>>1;                                              * 
*                  y0[k] = yt4; y0[k+1] = yt5;                             * 
*                  k += n>>1;                                              * 
*                  y0[k] = yt6; y0[k+1] = yt7;                             * 
*          }                                                               * 
*      }                                                                   * 
*                                                                          * 
* Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/   * 
*                                                                          *
*                                                                          *
*  Redistribution and use in source and binary forms, with or without      *
*  modification, are permitted provided that the following conditions      *
*  are met:                                                                *
*                                                                          *
*    Redistributions of source code must retain the above copyright        *
*    notice, this list of conditions and the following disclaimer.         *
*                                                                          *
*    Redistributions in binary form must reproduce the above copyright     *
*    notice, this list of conditions and the following disclaimer in the   *
*    documentation and/or other materials provided with the                *
*    distribution.                                                         *
*                                                                          *
*    Neither the name of Texas Instruments Incorporated nor the names of   *
*    its contributors may be used to endorse or promote products derived   *
*    from this software without specific prior written permission.         *
*                                                                          *
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     *
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT       *
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   *
*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    *
*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   *
*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT        *
*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   *
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   *
*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     *
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   *
*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    *
*                                                                          *
* =======================================================================  *
                .sect ".text:psa"
                .if __TI_EABI__
                .asg  DSP_fft16x16r, _DSP_fft16x16r
                .endif
					

        .global _DSP_fft16x16r
_DSP_fft16x16r: .cproc A_n, B_ptr_x, A_ptr_w, A_ptr_y, B_radix, A_offset, B_nmax
            .no_mdep
*============================================================================*
        .reg    B_x_
        .reg    A_j, B_j, A_w0, A_w1, B_w2, B_x, B_h2
        .reg    B_l1, B_l2, A_h2, A_l1, A_l2
        .reg    A_co11_si11:A_co10_si10
        .reg    B_co31_si31:B_co30_si30
        .reg    A_co21_si21:A_co20_si20
        .reg    B_xl1_3_xl1_2:B_xl1_1_xl1_0
        .reg    A_xh2_3_xh2_2:A_xh2_1_xh2_0
        .reg    A_xl2_3_xl2_2:A_xl2_1_xl2_0
        .reg    B_xh1_0_xh0_0:B_xl1_0_xl0_0
        .reg    A_xh21_1_xh20_1:A_xl21_1_xl20_1
        .reg    B_yt2_0_xt1_0:B_yt1_0_xt2_0
        .reg    B_yt2_1_xt1_1:B_yt1_1_xt2_1
        .reg    B_xt1_0_yt1_0:B_xt2_0_yt2_0
        .reg    B_xt1_1_yt1_1:B_xt2_1_yt2_1
        .reg    B_xh0_0_xh0_0, B_xh1_1_xh0_1
        .reg    A_xl1_1_xl0_1, A_xl0_0_xl1_0
        .reg    B_xh21_0_xh20_0, B_xh21_1_xh20_1
        .reg    A_xl21_0_xl20_0
        .reg    A_x_h2_0_1, A_x_h2_2_3
        .reg    A_xl1_1_0, A_yt0_1_xt0_1, A_xl1_3_2
        .reg    B_x_l2_0_1, B_x_l2_2_3
        .reg    A_x1,B_x1, A_x_, A_x__
        .reg    A_fft_jmp
        .reg    A_ifj, B_ifj
        .reg    B_fft_jmp
        .reg    A_x_3_x_2:A_x_1_x_0
        .reg    B_x_3_x_2:B_x_1_x_0
        .reg    A_xl20_0_xl21_0, A_xl20_1_xl21_1
        .reg    A_yt2_0_xt1_0, A_yt1_0_xt2_0
        .reg    A_yt2_1_xt1_1, A_yt1_1_xt2_1
        .reg    A_xt1_0_yt1_0, A_xt2_0_yt2_0
        .reg    A_xt1_1_yt1_1, A_xt2_1_yt2_1
        .reg    B_xt0_0_yt0_0, B_xt0_1_yt0_1
        .reg    A_yt1_0_xt1_0, A_yt1_1_xt1_1
        .reg    A_yt2_0_xt2_0, A_yt2_1_xt2_1
        .reg    A_xh1_0_xh0_0, A_xh21_0_xh20_0
        .reg    A_xt1_0_yt2_0, A_xt2_0_yt1_0
        .reg    A_x_h2_0, A_x_h2_1, A_x_h2_2, A_x_h2_3, B_x_l1_1, B_x_l1_0
        .reg    B_x_l1_2, B_x_l1_3, B_x_l2_0, B_x_l2_1, B_x_l2_2, B_x_l2_3
        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0
        .reg    B_x_3o_x_2o:B_x_1o_x_0o
        .reg    A_xl1_0_xl0_0
        .reg    A_xl1_0_1, A_xl1_2_3
        .reg    A_tw_offset, B_stride,B_stride_1, B_while
        .reg    B_c10, A_x0, A_xo2, B_xo3
        .reg    A_tbta, A_t3t2
        .reg    B_x7x6:B_x5x4, B_x3x2:B_x1x0
        .reg    A_x7x6:A_x5x4, A_x3x2:A_x1x0
        .reg    B_y9y8:B_y1y0, B_ydyc:B_y5y4
        .reg    A_yfye:A_y7y6, A_ybya:A_y3y2
        .reg    B_yt0_0_xt0_0, B_yt0_1_xt0_1
        .reg    B_fft_jmp_1, B_xl21_1_xl20_1
        .reg    A_xbxa:A_x9x8, B_xfxe:B_xdxc
        .reg    A_yt0_0_xt0_0, A_xt2_1_yt1_1
        .reg    B_xl1_1_xl0_1, A_xl0_1_xl1_1, A_xt1_1_yt2_1
        .reg    B_n, B_x0, B_n_2, B_nm2
        .reg    B_y0, B_y1, B_y2, B_y3, B_h0, B_h1, B_h3, B_h4
        .reg    A_i, A_r2, B_j0
        .reg    A_rnd, B_rnd
        .reg    B_xh1_2_xh0_2, A_xl1_2_xl0_2, A_xl1_3_xl0_3, B_xl1_3_xl0_3
        .reg    B_xh1_3_xh0_3, A_xl0_2_xl1_2, B_zero, A_zero
        .reg    A_mx7mx6, B_mxfmxe, A_yt7_yt2, A_yt3_yt6
        .reg    A_yte_ytb, A_yta_ytf, B_early
        .reg    A_myt0_0_mxt0_0
        .reg    A_myt0_1_mxt0_1
        .reg    B_xl0_0_xl1_0
        .reg    B_xl0_1_xl1_1
        .reg    B_xt1_0_yt2_0:B_xt2_0_yt1_0
        .reg    B_xt1_1_yt2_1:B_xt2_1_yt1_1
        .reg    B_yt1_0_xt1_0:B_yt2_0_xt2_0
        .reg    B_yt1_1_xt1_1:B_yt2_1_xt2_1
        .reg    A_x_h2_1_0
        .reg    A_x_h2_3_2

*============================================================================*


        ;----------------------------------------------------------;
        ; Initially set stride = n. The "tw_offset" is set to zero ;
        ; and is the offset that is added to the twiddle factor    ;
        ; pointer "ptr_w" for the current iteration. At the start  ;
        ; of the program "tw_offset" is 0.                         ;
        ;----------------------------------------------------------;

        MV.2x      A_n,                   B_stride
        ZERO.1     A_tw_offset





LOOP_WHILE:

        ;---------------------------------------------------------;
        ; "j" is an index into the twiddle factor array. At the   ;
        ; start of every iteration of the outer loop, it is re    ;
        ; set to zero.                                            ;
        ;---------------------------------------------------------;

        ZERO.1     A_j
        ZERO.2     B_j

        ;---------------------------------------------------------;
        ; For every iteration of the inner loop, 6 * stride,      ;
        ; twiddle factors are loaded, where half of them are      ;
        ; cosines and the other half are sines. Since the data    ;
        ; is being accessed as double words. The fft_jmp is       ;
        ; set to fft_jmp/8                                        ;
        ;---------------------------------------------------------;

        SHL.2      B_stride,              1,                   B_stride_1
        ADD.2      B_stride,              B_stride_1,          B_fft_jmp
        SHRU.1x    B_fft_jmp,             3,                   A_fft_jmp

        ;---------------------------------------------------------;
        ; Input data offsets are set for double words             ;
        ; h2: loads &x[N/2] where x is a short array, hence its   ;
        ; double word offset is N/8. Similar argument holds for   ;
        ; l1 and l2.                                              ;
        ;---------------------------------------------------------;


        SHRU.2     B_stride,              3,                   B_h2
        SHRU.2     B_stride,              2,                   B_l1
        ADD.2      B_l1,                  B_h2,                B_l2

        ;---------------------------------------------------------;
        ; Make partitioning copies of the indexes into oppsoite   ;
        ; data paths.                                             ;
        ;---------------------------------------------------------;

        MV.1x      B_l1,                  A_l1
        MV.1x      B_h2,                  A_h2
        MV.1x      B_l2,                  A_l2

        ;---------------------------------------------------------;
        ; Reset data pointer, derive twin twiddle factors.        ;
        ; Add twiddle offset to ptr_w to derive new twiddle       ;
        ; factor pointer.                                         ;
        ;---------------------------------------------------------;

        MV.2       B_ptr_x,               B_x
        ADDAH.1    A_ptr_w,               A_tw_offset,         A_w0

        ADD.1      A_w0,                  8,                   A_w1
        ADD.2x     A_w1,                  8,                   B_w2

        SHRU.2     B_fft_jmp,             1,                   B_fft_jmp_1
        ADD.1x     A_tw_offset,           B_fft_jmp_1,         A_tw_offset

        ;---------------------------------------------------------;
        ; The stride is quartered with every iteration of the     ;
        ; outer loop until stride = 4.                            ;
        ;---------------------------------------------------------;

        SHRU.2     B_stride,              2,                   B_stride

        ;---------------------------------------------------------;
        ; The following loop iterates for N/8 iterations. Since   ;
        ; BDEC is used 2 needs to be subtracted from the loop     ;
        ; counter A_i.                                            ;
        ;---------------------------------------------------------;

        SHRU.1     A_n,                   3,                   A_i
        SUB.1      A_i,                   2,                   A_i
        SUB.1      A_fft_jmp,             3,                   A_fft_jmp



        ;---------------------------------------------------------;
        ; Since the stride amount across iterations is variable,  ;
        ; it is tough to put an exact stride. However for this    ;
        ; loop stride is guranteed to be greater than or equal    ;
        ; to 16 complex samples, 32 half words. Since this str-   ;
        ; ide is wider than the bank width, of all the banks,     ;
        ; stride is specified as zero.                            ;
        ;---------------------------------------------------------;


        .mptr      A_w0,   x+0,     0
        .mptr      A_w1,   x+2,     0
        .mptr      B_x,    x+0,     0
        .mptr      A_x_,   x+0,     0

LOOP_Y: .trip      3

        ;---------------------------------------------------------;
        ; Load three twiddle factors for the first radix4 butter- ;
        ; fly, and the next three twiddle factors for the second  ;
        ; radix4 butterfly.                                       ;
        ; si10=w[0]   co10=w[1]    si11=w[2]   co11=w[3]          ;
        ; si20=w[4]   co20=w[5]    si21=w[6]   co21=w[7]          ;
        ; si30=w[8]   co30=w[9]    si31=w[a]   co31=w[b]          ;
        ;---------------------------------------------------------;

        LDDW.D2T1  *A_w0[A_j],            A_co11_si11:A_co10_si10
        LDDW.D1T1  *A_w1[A_j],            A_co21_si21:A_co20_si20
        LDDW.D2T2  *B_w2[B_j],            B_co31_si31:B_co30_si30

        ;---------------------------------------------------------;
        ; Load the complex input data for the first radix4 bfly.  ;
        ; x[0]    x[1]    x[2]    x[3]                            ;
        ; x[h2+0] x[h2+1] x[h2+2] x[h2+3]                         ;
        ; x[l1+0] x[l1+1] x[l1+2] x[l1+3]                         ;
        ; x[l2+0] x[l2+1] x[l2+2] x[l2+3]                         ;
        ; These loads cannot parallelize as they could have bank  ;
        ; conflicts.                                              ;
        ;---------------------------------------------------------;

        LDDW.D2T2  *B_x[0],               B_x_3_x_2:B_x_1_x_0
        LDDW.D2T1  *B_x[B_h2],            A_xh2_3_xh2_2:A_xh2_1_xh2_0
        LDDW.D2T2  *B_x[B_l1],            B_xl1_3_xl1_2:B_xl1_1_xl1_0
        LDDW.D2T1  *B_x[B_l2],            A_xl2_3_xl2_2:A_xl2_1_xl2_0


        ;---------------------------------------------------------;
        ; Make copies of the input pointer so that stores take    ;
        ; place. Use the delayed move instruction to avoid live   ;
        ; too longs.                                              ;
        ;---------------------------------------------------------;

        MVD.2     B_x,                   B_x_
        MVD.1x      B_x_,                  A_x__

        ;---------------------------------------------------------;
        ; Check if the current twiddle factor sub-table has been  ;
        ; exhausted. If so reest twiddle factor index to zero,    ;
        ; and increment the data pointer by the "fft_jmp" so      ;
        ; that the data elements that re-use the twiddle factor   ;
        ; may be loaded.                                          ;
        ;                                                         ;
        ; if (!(j - fft_jmp))                                     ;
        ; {                                                       ;
        ;     j += 12 shorts;                                     ;
        ;     x += fft_jmp;                                       ;
        ;     j = 0;                                              ;
        ; }                                                       ;
        ;     x += 4(shorts)                                      ;
        ;---------------------------------------------------------;

        ;---------------------------------------------------------;
        ; Since the twiddle factor array is loaded in as doubles  ;
        ; the increment by 12 shorts is done as an add by 3, as   ;
        ; the load double word scales this offset by 4.           ;
        ;---------------------------------------------------------;

        SUB.S1      A_fft_jmp,             A_j,                A_ifj
        ADD.S1      A_j,                   3,                  A_j

        ;----------------------------------------------------------;
        ; If j equals fft_jmp, then the data pointer is incr-      ;
        ; emented by this amount, so that twiddle factors can be   ;
        ; re-used.                                                 ;
        ;----------------------------------------------------------;

[!A_ifj]ADD.D2      B_x,                   B_fft_jmp,          B_x
[!A_ifj]ZERO.L1     A_j
         MV         A_j,                   B_j
        ADD.S2      B_x,                   8,                  B_x


        ;--------------------------------------------------------;
        ; Perform radix2 style DIF equations on input data       ;
        ; The subscript "h" refers to high and "l" refers to low ;
        ; xh0_0  =  x[0] + x[l1]    xh1_0  =  x[1] + x[l1+1]     ;
        ; xh0_1  =  x[2] + x[l1+2]  xh1_1  =  x[3] + x[l1+3]     ;
        ; xl0_0  =  x[0] - x[l1]    xl1_0  =  x[1] - x[l1+1]     ;
        ; xl0_1  =  x[2] - x[l1+2]  xl1_1  =  x[3] - x[l1+3]     ;
        ;--------------------------------------------------------;

        ADDSUB2.L2  B_x_1_x_0,      B_xl1_1_xl1_0,  B_xh1_0_xh0_0:B_xl1_0_xl0_0
        ADDSUB2.L2  B_x_3_x_2,      B_xl1_3_xl1_2,  B_xh1_1_xh0_1:B_xl1_1_xl0_1


        ;--------------------------------------------------------;
        ; xh20_0 = x[h2  ] + x[l2  ]   xh21_0 = x[h2+1] + x[l2+1];
        ; xh20_1 = x[h2+2] + x[l2+2]   xh21_1 = x[h2+3]+x[l2+3]  ;
        ; xl20_0 = x[h2  ] - x[l2  ];  xl21_0 = x[h2+1] - x[l2+1];
        ; xl20_1 = x[h2+2] - x[l2+2];  xl21_1 = x[h2+3] - x[l2+3];
        ;--------------------------------------------------------;

        ADDSUB2.L1  A_xh2_1_xh2_0,  A_xl2_1_xl2_0,  A_xh21_0_xh20_0:A_xl21_0_xl20_0
        ADDSUB2.L1  A_xh2_3_xh2_2,  A_xl2_3_xl2_2,  A_xh21_1_xh20_1:A_xl21_1_xl20_1

        ;----------------------------------------------------------;
        ; Compute first set of outputs:                            ;
        ;                                                          ;
        ;  x0[0]= xh0_0 + xh20_0 + 1 >> 1                          ;
        ;  x0[1]= xh1_0 + xh21_0 + 1 >> 1                          ;
        ;  x0[2]= xh0_1 + xh20_1 +1  >> 1                          ;
        ;  x0[3]= xh1_1 + xh21_1 +1  >> 1                          ;
        ;----------------------------------------------------------;

        AVG2.2     A_xh21_0_xh20_0,       B_xh1_0_xh0_0,      B_x_1o_x_0o
        AVG2.2     A_xh21_1_xh20_1,       B_xh1_1_xh0_1,      B_x_3o_x_2o

        ;----------------------------------------------------------;
        ; xt0_0 = xh0_0 - xh20_0  yt0_0 = xh1_0 - xh21_0           ;
        ; xt0_1 = xh0_1 - xh20_1  yt0_1 = xh1_1 - xh21_1           ;
        ;----------------------------------------------------------;

        SUB2.L1X     A_xh21_0_xh20_0,     B_xh1_0_xh0_0,     A_myt0_0_mxt0_0
        SUB2.L1X     A_xh21_1_xh20_1,     B_xh1_1_xh0_1,     A_myt0_1_mxt0_1


        ;----------------------------------------------------------;
        ; Perform a halfword swizzle so that xl0 can be combined   ;
        ; with xl21, xl1 can be combined with xl20. This is a      ;
        ; reult of the multiplication by the j term                ;
        ;----------------------------------------------------------;

        PACKLH2.S2  B_xl1_0_xl0_0,       B_xl1_0_xl0_0,    B_xl0_0_xl1_0
        PACKLH2.S2  B_xl1_1_xl0_1,       B_xl1_1_xl0_1,    B_xl0_1_xl1_1

        ;----------------------------------------------------------;
        ; xt1_0 = xl0_0 + xl21_0   yt2_0 = xl1_0 + xl20_0          ;
        ; xt1_1 = xl0_1 + xl21_1   yt2_1 = xl1_1 + xl20_1          ;
        ; xt2_0 = xl0_0 - xl21_0   yt1_0 = xl1_0 - xl20_0          ;
        ; xt2_1 = xl0_1 - xl21_1   yt1_1 = xl1_1 - xl20_1          ;
        ;----------------------------------------------------------;


        ADDSUB2.L2X  B_xl0_0_xl1_0,    A_xl21_0_xl20_0, B_xt1_0_yt2_0:B_xt2_0_yt1_0
        ADDSUB2.L2X  B_xl0_1_xl1_1,    A_xl21_1_xl20_1, B_xt1_1_yt2_1:B_xt2_1_yt1_1


        ;----------------------------------------------------------;
        ; Since yt2 and xt1 get packed together, we need to do     ;
        ; a few more packs to get terms yt1,xt1 packed together    ;
        ; This operation is akin to taking a 2x2 transpose.        ;
        ; This allows us to get packed xy's for  the three other   ;
        ; inputs of the butterfly.                                 ;
        ;----------------------------------------------------------;

        DPACKX2.L2  B_xt1_0_yt2_0,    B_xt2_0_yt1_0,   B_yt1_0_xt1_0:B_yt2_0_xt2_0
        DPACKX2.L2  B_xt1_1_yt2_1,    B_xt2_1_yt1_1,   B_yt1_1_xt1_1:B_yt2_1_xt2_1


        ;---------------------------------------------------------;
        ; Notice that in this version of the code the two middle  ;
        ; legs are swapped as indicated by the stores to x[l1]..  ;
        ; x[l1 + 3] which preceede the stores to x[h2]..x[h2 + 3] ;
        ; This reversal guarantees that a radix4 DIF butterfly    ;
        ; produces results in digit reversed order. Note that in  ;
        ; addition to the rounding, the shift is performed by 16, ;
        ; as opposed to 15, to give scaling.                      ;
        ;---------------------------------------------------------;

        ;---------------------------------------------------------;
        ;                                                         ;
        ; x2[l1  ] = (si10 * yt1_0 + co10 * xt1_0 + 0x4000) >> 16 ;
        ; x2[l1+1] = (co10 * yt1_0 - si10 * xt1_0 + 0x4000) >> 16 ;
        ; x2[l1+2] = (si11 * yt1_1 + co11 * xt1_1 + 0x4000) >> 16 ;
        ; x2[l1+3] = (co11 * yt1_1 - si11 * xt1_1 + 0x4000) >> 16 ;
        ;                                                         ;
        ; These four results are retained in registers and a      ;
        ; double word is formed so that it can be stored with     ;
        ; one STDW.                                               ;
        ;---------------------------------------------------------;

        CMPYR .1  A_co10_si10,   B_yt1_0_xt1_0, A_xh2_1_0;
        CMPYR .1  A_co11_si11,   B_yt1_1_xt1_1, A_xh2_3_2;

        ;---------------------------------------------------------;
        ; The following code computes intermediate results for:   ;
        ;                                                         ;
        ; x2[h2  ] = (si20 * yt0_0 + co20 * xt0_0 + 0x4000) >> 16 ;
        ; x2[h2+1] = (co20 * yt0_0 - si20 * xt0_0 + 0x4000) >> 16 ;
        ; x2[h2+2] = (si21 * yt0_1 + co21 * xt0_1 + 0x4000) >> 16 ;
        ; x2[h2+3] = (co21 * yt0_1 - si21 * xt0_1 + 0x4000) >> 16 ;
        ;---------------------------------------------------------;


         CMPYR .1  A_co20_si20,   A_myt0_0_mxt0_0, A_xl1_1_0;
         CMPYR .1  A_co21_si21,   A_myt0_1_mxt0_1, A_xl1_3_2;

        ;---------------------------------------------------------;
        ; The following code computes intermediate results for:   ;
        ;                                                         ;
        ; x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0 + 0x4000) >> 16 ;
        ; x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0 + 0x4000) >> 16 ;
        ; x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1 + 0x4000) >> 16 ;
        ; x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1 + 0x4000) >> 16 ;
        ;---------------------------------------------------------;

        CMPYR .2  B_co30_si30,   B_yt2_0_xt2_0,  B_xl2_1_0;  si = -si
        CMPYR .2  B_co31_si31,   B_yt2_1_xt2_1,  B_xl2_3_2;

        ;---------------------------------------------------------;
        ; Store out the outputs to the four legs of the butterfly ;
        ; using aligned store double words. Notice the use of the ;
        ; indices "l1", "l2", "h2" to derive the pointers for the ;
        ; legs of the butterfly.                                  ;
        ;---------------------------------------------------------;

        STDW.D1T2  B_x_3o_x_2o:B_x_1o_x_0o,  *A_x__[0   ]
        STDW.D1T1  A_xl1_3_2:A_xl1_1_0,      *A_x__[A_h2]
        STDW.D1T1  A_xh2_3_2:A_xh2_1_0,      *A_x__[A_l1]
        STDW.D1T2  B_xl2_3_2:B_xl2_1_0,      *A_x__[A_l2]
        ;---------------------------------------------------------;
        ; Decrement and branch on loop variable A_i.              ;
        ;---------------------------------------------------------;

        BDEC.1     LOOP_Y,                A_i

        ;---------------------------------------------------------;
        ; Continue to use this loop as long as stride > radix     ;
        ;---------------------------------------------------------;

        CMPGTU.2   B_stride,              B_radix,            B_while
[B_while]B.2       LOOP_WHILE


        ;---------------------------------------------------------;
        ; The following condition allows fft to become a multiple ;
        ; call FFT as it exits as soon as stride, between two     ;
        ; legs becomes greater than the radix.                    ;
        ;---------------------------------------------------------;

        CMPGTU.2   B_radix,               4,                  B_early
[B_early]B.2       EARLY_EXIT

        ;---------------------------------------------------------;
        ; Check if radix is 2, and prepare zero for each data     ;
        ; path.                                                   ;
        ;---------------------------------------------------------;

        SUB.2      B_radix,               2,                  A_r2
        ZERO.1     A_zero
        ZERO.2     B_zero

        ;---------------------------------------------------------;
        ; Prepare twin data pointers. In addition prepare four    ;
        ; output pointers as follows:                             ;
        ; y0 = ptr_y                                              ;
        ; y1 = y0 + (nmax >> 1)                                   ;
        ; y2 = y1 + (nmax >> 1)                                   ;
        ; y3 = y2 + (nmax >> 1)                                   ;
        ;---------------------------------------------------------;

        MV.1x      B_ptr_x,               A_x0
        ADD.2      B_ptr_x,               8,                  B_x0

        MV.2x      A_ptr_y,               B_y0
        ADD.2      B_y0,                  B_nmax,             B_y1
        ADD.2      B_y1,                  B_nmax,             B_y2
        ADD.2      B_y2,                  B_nmax,             B_y3

        ;--------------------------------------------------------;
        ; Determine the norm, and derive shift amount by adding  ;
        ; 4 to it.                                               ;
        ;--------------------------------------------------------;

        NORM.2     B_nmax,                B_l1
        ADD.2      B_l1,                  4,                  B_l1

        ;--------------------------------------------------------;
        ; Loop trip counter is n >> 2. In addition deduct 2 for  ;
        ; BDEC. Set j to be offset >> 2                          ;
        ;--------------------------------------------------------;

        SHRU.1     A_n,                   2,                  A_i
        SUB.1      A_i,                   2,                  A_i
        SHRU.2     A_offset,              2,                  B_j

        ;--------------------------------------------------------;
        ; Infrom the compiler that there are twin data pointers  ;
        ; A_x0, B_x0. In addition inform compiler that there     ;
        ; is one data pointer for B side.                        ;
        ;--------------------------------------------------------;

        .mptr      A_x0,   A_x + 0, 16
        .mptr      B_x0,   A_x + 1, 16
        .mptr      B_y0,   A_x + 0, 0

LOOP_Z: .trip      4

        ;--------------------------------------------------------;
        ; The following performs bit reversal of index "j"       ;
        ; of size "l0" bits into index "k". This forms the index ;
        ; with respect to pointers y0, y1, y2, y3 into which  4  ;
        ; consecutive inputs map into.                           ;
        ;--------------------------------------------------------;

        BITR.2     B_j,                   B_h3
        SHRU.2     B_h3,                  B_l1,               B_h4
        ADD.2      B_j,                   1,                  B_j

        ;-------------------------------------------------------;
        ; Load input data using double word wide loads. In add- ;
        ; ition make partitioning copy using M unit to avoid    ;
        ; variables that live too long.                         ;
        ;-------------------------------------------------------;

        LDDW.D1T1  *A_x0++[2],            A_x3x2:A_x1x0
        LDDW.D2T2  *B_x0++[2],            B_x7x6:B_x5x4
        ROTL.1x    B_x7x6,                0,                  A_x7x6

        ;-------------------------------------------------------;
        ; Read in the input data, from the first eight locns.   ;
        ; These results are transformed as radix 4              ;
        ;  xl0_0  = x_0 - x_4; xl1_0  = x_1 - x_5;              ;
        ;  xl0_1  = x_2 - x_6; xl1_1  = x_3 - x_7;              ;
        ;-------------------------------------------------------;

        SUB2.1x    A_x1x0,                B_x5x4,             A_xl1_0_xl0_0
        SUB2.1     A_x3x2,                A_x7x6,             A_xl1_1_xl0_1

        ;-------------------------------------------------------;
        ; Swizzle the data and compute the negative for change  ;
        ; if radix is 2 rather than 4.                          ;
        ;-------------------------------------------------------;

        ROTL.1     A_xl1_1_xl0_1,         16,                 A_xl0_1_xl1_1
        SUB2.1     A_zero,                A_x7x6,             A_mx7mx6

        ;------------------------------------------------------;
        ; These results are appropriately changed if radix     ;
        ; is 2, so that when the next set of radix 4 steps     ;
        ; performed then the results are same as radix 2.      ;
        ;                                                      ;
        ; xl0_0   =   x_4;     xl1_0   =   x_5;                ;
        ; xl1_1   =   x_6;     xl0_1   =   -x_7;               ;
        ;------------------------------------------------------;

[!A_r2] ROTL.1x    B_x5x4,                0,                  A_xl1_0_xl0_0
[!A_r2] PACKHL2.1  A_mx7mx6,              A_x7x6,             A_xl0_1_xl1_1

        ;------------------------------------------------------;
        ; Perform nest step of radix4 for lower leg. This will ;
        ; result in the correct results radix4 or radix2       ;
        ; yt2  = xl0_0 + xl1_1; yt7  = xl1_0 + xl0_1;          ;
        ; yt6  = xl0_0 - xl1_1; yt3  = xl1_0 - xl0_1;          ;
        ;------------------------------------------------------;

        ADD2.1     A_xl1_0_xl0_0,         A_xl0_1_xl1_1,      A_yt7_yt2
        SUB2.1     A_xl1_0_xl0_0,         A_xl0_1_xl1_1,      A_yt3_yt6

        ;------------------------------------------------------;
        ; Repack results so that dajacent results are packed to;
        ; gether for comitting to memory as a store double word;
        ;------------------------------------------------------;


        PACKHL2.1  A_yt3_yt6,             A_yt7_yt2,          A_y3y2
        PACKHL2.1  A_yt7_yt2,             A_yt3_yt6,          A_y7y6

        ;-----------------------------------------------------;
        ; Zero out the contributions of x4..x7 for the high   ;
        ; leg if the radix is 2, rememebering that the cont-  ;
        ; ributions are restricted within four points.        ;
        ;  x_4 = x_5 = x_6 = x_7 = 0;                         ;
        ;-----------------------------------------------------;

[!A_r2] MPY2.2     B_zero,                B_zero,             B_x7x6:B_x5x4

        ;-----------------------------------------------------;
        ; Perform radix4 decomposition as a series of radix2  ;
        ; compositions. This yields yt1:yt0 and yt5:yt4       ;
        ;                                                     ;
        ;  xh0_0  = x_0   +  x_4;     xh1_0  = x_1 + x_5;     ;
        ;  xh0_1  = x_2   +  x_6;     xh1_1  = x_3 + x_7;     ;
        ;  yt0    = xh0_0 +  xh0_1;   yt1  = xh1_0 + xh1_1;   ;
        ;  yt4    = xh0_0 -  xh0_1;   yt5  = xh1_0 - xh1_1;   ;
        ;                                                     ;
        ;-----------------------------------------------------;

        ADD2.2     B_x5x4,                A_x1x0,             B_xh1_0_xh0_0
        ADD2.2     B_x7x6,                A_x3x2,             B_xh1_1_xh0_1
        ADD2.2     B_xh1_0_xh0_0,         B_xh1_1_xh0_1,      B_y1y0
        SUB2.2     B_xh1_0_xh0_0,         B_xh1_1_xh0_1,      B_y5y4

        ;-----------------------------------------------------;
        ;  Store out the results of the radix4 butterfly as 4 ;
        ; or the result of 2 radix2 butterflies. These results;
        ; are stored out using store words _amem4 intrinsic.  ;
        ;-----------------------------------------------------;

        STW.D2T2   B_y1y0,                *B_y0[B_h4]
        STW.D2T1   A_y3y2,                *B_y1[B_h4]
        STW.D2T2   B_y5y4,                *B_y2[B_h4]
        STW.D2T1   A_y7y6,                *B_y3[B_h4]

        ;-----------------------------------------------------;
        ; Decrement and branch on loop variable A_i.          ;
        ;-----------------------------------------------------;

        BDEC.1     LOOP_Z,                A_i

        ;-----------------------------------------------------;
        ;  Early exit for early return                        ;
        ;-----------------------------------------------------;

EARLY_EXIT:

        .return

                .endproc

* ======================================================================== *
*  End of file: DSP_fft16x16r_sa.sa                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2011 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
