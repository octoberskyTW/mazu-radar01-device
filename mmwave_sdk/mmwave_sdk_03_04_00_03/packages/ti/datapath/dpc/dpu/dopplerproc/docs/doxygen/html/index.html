<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Doppler DPU</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Doppler DPU </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This DPU implements the Doppler FFT (2D FFT).</p>
<h1><a class="anchor" id="dopplerdpu_intro_section"></a>
Doppler DPU</h1>
<h2>Description </h2>
<p>This DPU expects as input the radar cube with 1D FFT data as described in <a class="el" href="group___d_p_i_f___r_a_d_a_r_c_u_b_e___f_o_r_m_a_t.html#ga4f1cc2e5019a697f3cafa1cecdf3b144">DPIF_RADARCUBE_FORMAT_1</a>. The output of this DPU is a detection matrix of format described in <a class="el" href="group___d_p_i_f___d_e_t_m_a_t_r_i_x___f_o_r_m_a_t.html#gaaa138fe4aad1ad2db607a5fd68f82415">DPIF_DETMATRIX_FORMAT_1</a>. These are the only formats supported by this DPU.</p>
<p>The Doppler DPU is available in two distinct implementations:</p>
<table class="doxtable">
<tr>
<th align="left">DPU Implementation </th><th align="left">Runs on cores </th><th align="left">Uses HWA  </th></tr>
<tr>
<td align="left">dopplerProcHWA </td><td align="left">R4F or DSP </td><td align="left">Yes </td></tr>
<tr>
<td align="left">dopplerProcDSP </td><td align="left">DSP </td><td align="left">No </td></tr>
</table>
<p><br />
<br />
</p>
<h1><a class="anchor" id="doppler_hwa_dpu"></a>
DopplerProcHWA</h1>
<p>Data from radar cube is moved into HWA memory using EDMA, HWA performs the required computations and data is moved by EDMA from HWA internal memory to the detection matrix.<br />
<br />
 The following figure shows a high level block diagram of the DPU implementation.<br />
 </p><div class="image">
<img src="hwa_doppler_toplevel.png" alt="hwa_doppler_toplevel.png"/>
<div class="caption">
HWA based Doppler DPU High Level block diagram</div></div>
<p> A list of resources required by this DPU is described in <a class="el" href="struct_d_p_u___doppler_proc_h_w_a___h_w___resources__t.html">DPU_DopplerProcHWA_HW_Resources_t</a>. In particular, the number of EDMA channels required is constant and does not depend on the DPU configuration. On the other hand, the number of required HWA paramsets is a function of the number of TX antennas configured in the data path as described in <a class="el" href="struct_d_p_u___doppler_proc_h_w_a___hwa_cfg__t.html">DPU_DopplerProcHWA_HwaCfg_t</a>.<br />
 Besides the resources described above, other parameters required for the DPU configuration are listed in <a class="el" href="struct_d_p_u___doppler_proc_h_w_a___static_config__t.html">DPU_DopplerProcHWA_StaticConfig_t</a>. In particular, the DPU takes as input the number of Doppler chirps (numDopplerChirps), which does not need to be a power of two. It produces a detection matrix of Doppler dimension equal to numDopplerBins which must be a power of 2 greater or equal than numDopplerChirps. Another DPU input is the number of range bins, which must be even but does not need to be a power of two.<br />
<br />
</p>
<table class="doxtable">
<tr>
<th align="left">Parameter </th><th align="left">Restriction  </th></tr>
<tr>
<td align="left">numDopplerChirps </td><td align="left">None. </td></tr>
<tr>
<td align="left">numDopplerBins </td><td align="left">Must be power of two greater or equal than numDopplerChirps. </td></tr>
<tr>
<td align="left">numRangeBins </td><td align="left">Must be even. </td></tr>
</table>
<p>Below are details of the DPU implementation:<br />
 EDMA is used to move data from the radar cube into the HWA internal memory and after processing is done to move data from HWA internal memory to the detection matrix. All 4 HWA memory banks are required by this DPU, regardless of the DPU configuration. In this document, the HWA memory banks are called M0, M1, M2, M3.<br />
</p>
<p>A ping/pong buffer scheme is used where:<br />
 M0 and M2 are used for ping input/processing.<br />
 M1 and M3 are used for pong input/processing.<br />
 In each iteration (ping/pong), a column of the radar cube matrix is brought into HWA for processing. Such column consists of all samples for a fixed range, that is, all received virtual antennas for all Doppler chirps for a fixed range bin.<br />
 The steps below are executed by HWA on data (one column of the radar cube as described above) sitting in its M memory. The description below is given for processing the ping buffer. Pong buffer processing is identical to ping, except that M0 memory is replaced by M1 and M2 memory is replaced by M3.<br />
<br />
 <b>Windowing</b><br />
 Before FFT operation, input samples are multiplied by a window function. Window size and coefficients are defined in <a class="el" href="struct_d_p_u___doppler_proc_h_w_a___hwa_cfg__t.html">DPU_DopplerProcHWA_HwaCfg_t</a>.<br />
 Window coefficients must be provided by application.<br />
<br />
 <b>FFT and Log2|.|</b><br />
 In this step 2D FFT and Log2 of the absolute value of each sample is computed. Input samples are in M0 and output samples are in M2. Input sample is of type cmplx16ImRe_t and output is of type uint16_t. This step also converts the number of input samples from N = numDopplerChirps to a number of output samples K = numDopplerBins, which is the size of the Doppler FFT. Both numDopplerBins and numDopplerChirps are input parameters for this DPU and numDopplerBins must be a power of 2 greater or equal than numDopplerChirps. <br />
<br />
</p>
<p><b>Summation</b><br />
 Summation of all virtual antennas is computed for each Doppler bin. <br />
 The output of the previous step (HWA Log2 magnitude) is in Q11 format. The sum is done using FFT in HWA, the sum is obtained in the DC (0th) bin. Input of the summation is on M2 and output is on M0. This FFT programming has srcScale of 3, meaning 3 redundant bits (sign extension, in this case unsigned) are added to MSB and 5 LSBs are padded with 0, so input before computation is in Q[11 + 5] format. The dstScale is set to 8, so summation output will have 8-bits dropped, giving a result in Q[11 + 5 - 8] = Q8 format. The FFT size is the next power of 2 of number of virtual antennas and the FFT is programmed to enable all butterfly scaling stages, hence the FFT output will be 1/N' * sum(.), where N' = 2^Ceil(Log2(N)), where N = numVirtualAntennas. The sum output which is input to CFAR is in Q8 format, so the CFAR threshold-scale also needs to be in Q8 format. If CFAR threshold is originally intended to be expressed in dB (say for user friendliness), then we need to do some translation before feeding to the CFAR algorithm. This can be derived as follows: <br />
 Let N be the number of virtual antennas and N' = 2^ceil(log2(N)) and user friendly CFAR threshold in dB is TdB (= 20*log10(|.|)). CFAR needs to do in general: <br />
 CUT (Cell Under Test) = 1/N * sum(log10(|.|)) &gt; TdB/20 + average of noise terms [similar looking to CUT on LHS] <br />
 Given log10(|.|) = log2(|.|)/log2(10), and further adjusting the terms to do computation similar to match what is the sum output described above : <br />
 2^8 * 1/ N' * sum(log2(|.|)) &gt; TdB/20*log2(10)*2^8 * (N/N') + average of noise terms [similar looking to CUT on LHS] <br />
 So the CFAR threshold to be provided to the CFAR algorithm operating on this doppler DPU output is <br />
 T = 256 * TdB / 6 * N / N'</p>
<p>Once the summation is computed for all Doppler bins, EDMA transfers the result from M0 to the detection matrix.<br />
<br />
 <b>HWA memory bank size limitation</b><br />
 The following 2 conditions must be satisfied for the parameters in this DPU configuration:<br />
 4 x numRxAntennas x numTxAntennas x numDopplerChirps &lt;= 16384<br />
 2 x numRxAntennas x numTxAntennas x numDopplerBins &lt;= 16384<br />
<br />
 The reason for this limitation is as follows:<br />
 The size of the data that is brought in for processing in HWA (per ping/pong iteration) is a column of the radar cube. The size of radar cube column is<br />
 4 x numRxAntennas x numTxAntennas x numDopplerChirps (I),<br />
 where 4 bytes is sizeof(cmplx16ImRe_t), the sample size.<br />
 After the 2D FFT and Log2|.| , we go from Doppler chirps to Doppler bins and from cmplx16ImRe_t to uint16_t. <br />
 Therefore the size after 2D FFT and Log2|.| is<br />
 2 x numRxAntennas x numTxAntennas x numDopplerBins (II),<br />
 where 2 bytes is sizeof(uint16_t).<br />
<br />
 Both quantities above (I and II) should fit (independently) in one of the HWA M memory partitions which has a size of 16KB.<br />
<br />
 <b>Exported APIs</b><br />
 DPU initialization is done through <a class="el" href="group___d_p_u___d_o_p_p_l_e_r_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga28ac91fad2713702621dc60b2bc584e6">DPU_DopplerProcHWA_init</a>.<br />
<br />
 DPU configuration is done by <a class="el" href="group___d_p_u___d_o_p_p_l_e_r_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga20bf5ab5ea54cd9614c2c74bf0a786b7">DPU_DopplerProcHWA_config</a>. The configuration can only be done after the DPU has been initialized. The configuration parameters are described in <a class="el" href="group___d_p_u___d_o_p_p_l_e_r_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga773c45330ee7c15b7a3b4b954d02c8d2">DPU_DopplerProcHWA_Config</a>. <br />
<br />
 The DPU is executed by calling <a class="el" href="group___d_p_u___d_o_p_p_l_e_r_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gae2fda7b20c66b6eda41082912faf0948">DPU_DopplerProcHWA_process</a>. <br />
 This will trigger the first ping/pong EDMA transfers and from there on, the processing of the Doppler DPU for the full radar cube is driven by hardware: EDMA will move data in and trigger HWA, which will process the data and trigger EDMA to move data out (to detection matrix) and trigger next EDMA to move data in â€“ and so on. All columns of the radar cube matrix will be processed in this loop and no CPU intervention is needed. When HWA finishes processing all columns of the radar cube it will generate an interrupt. When the last EDMA transfer to the detection matrix has landed, EDMA will generate an interrupt. The DPU processing is done when both interrupts are received. Both interrupts are depicted in green boxes in the figure below.<br />
<br />
</p>
<p><b>Detailed block diagram for 3 TX 4 RX</b><br />
 The following figure depicts in detail the DPU implementation for the case of 3 TX and 4RX antennas. The blue boxes connected by blue arrows represent different HWA paramsets.<br />
<br />
 </p><div class="image">
<img src="hwa_doppler_fft.png" alt="hwa_doppler_fft.png"/>
<div class="caption">
Doppler DPU implementation for 3 TX and 4 RX antennas</div></div>
<p> <br />
<br />
<br />
 </p>
<h1><a class="anchor" id="dpu2"></a>
DopplerProcDSP</h1>
<p>In this version of the Doppler DPU HWA is not used. All computation is done by the DSP.<br />
 Data from radar cube is moved into scratch memory using EDMA, DSP performs the required computations and data is moved by EDMA from scratch memory to the detection matrix.<br />
<br />
 The following figure shows a high level block diagram of the DPU implementation.<br />
 </p><div class="image">
<img src="dsp_doppler_fft_toplevel.png" alt="dsp_doppler_fft_toplevel.png"/>
<div class="caption">
DSP Doppler DPU High Level block diagram</div></div>
<p> A list of resources required by this DPU is described in <a class="el" href="struct_d_p_u___doppler_proc_d_s_p___h_w___resources__t.html">DPU_DopplerProcDSP_HW_Resources_t</a>. In particular, the number of EDMA channels required is constant and does not depend on the DPU configuration.</p>
<p>Besides the resources described above, other parameters required for the DPU configuration are listed in <a class="el" href="struct_d_p_u___doppler_proc_d_s_p___static_config__t.html">DPU_DopplerProcDSP_StaticConfig_t</a>. In particular, the DPU takes as input the number of Doppler chirps (numDopplerChirps), which does not need to be a power of two but must be a multiple of 4. It produces a detection matrix of Doppler dimension equal to numDopplerBins which must be a power of 2 greater or equal than numDopplerChirps. Also, due to restrictions on the FFT implementation by DSPLIB, numDopplerBins must be at least 16.</p>
<table class="doxtable">
<tr>
<th align="left">Parameter </th><th align="left">Restriction  </th></tr>
<tr>
<td align="left">numDopplerChirps </td><td align="left">Must be a multiple of 4. </td></tr>
<tr>
<td align="left">numDopplerBins </td><td align="left">Must be at least 16. Must be power of two greater or equal than numDopplerChirps. </td></tr>
</table>
<p><br />
 Below are details of the DPU implementation:<br />
<br />
 <b>Input data</b><br />
 EDMA is used to move data from the radar cube into the DPU scratch buffers.<br />
 A ping/pong buffer scheme is used where in each iteration (ping/pong), data pertinent to one virtual antenna (for a fixed range bin) is brought from the radar cube matrix for processing. <br />
 For a fixed range bin, the order in which the virtual antennas are processed must assure that BPM can be decoded and all virtual antennas can be summed up. In order to achieve this goal with minimum temporary buffering of virtual antennas data, the sequence of virtual antennas is processed in the following order:<br />
<br />
 1) Next TX antennas for same range bin and same RX antenna. This assures that BPM can be decoded.<br />
 2) Once 1 is exhausted for all TX antennas for a fixed range bin and fixed RX antenna, move to the next RX antenna for the same range bin (to assure that the sum of all virtual antennas can be computed) and repeat 1.<br />
 3) Once all virtual antennas for this range bin have been processed, move to the next range bin.<br />
<br />
 Illustration of the ping/pong data pattern is shown in the next sections for the [3TX,4RX] and [2TX,4RX] cases.<br />
<br />
 <b>Static Clutter Removal</b><br />
 When Static Clutter Removal is enabled, the mean value of the input samples to the Doppler FFT is subtracted from the samples.<br />
<br />
 <b>Windowing</b><br />
 Before FFT operation, input samples are multiplied by a real symmetric window function. Window size and coefficients are defined in <a class="el" href="struct_d_p_u___doppler_proc_d_s_p___h_w___resources__t.html">DPU_DopplerProcDSP_HW_Resources_t</a>. Window coefficients must be provided by application.<br />
 Note that the windowing function also executes IQ swap. Before windowing the samples are in the same format as in the radar cube, which is cmplx16ImRe_t. After windowing the output is in cmplx32ReIm_t format.<br />
<br />
 <b>FFT</b><br />
 FFT is computed the output has numDopplerBins samples of type cmplx32ReIm_t.<br />
<br />
 <b>BPM decoding</b><br />
 If BPM is enabled, when the FFT output is available for the 2 TX antennas (for the same RX antenna and range bin), BPM is decoded. More details on BPM implementation in the following section.<br />
<br />
 <b>Log2|.|</b><br />
 Log2 of the absolute value of each sample is computed and the output is a 16 bit number in Q8 format.<br />
<br />
 <b>Summation and Output</b><br />
 Accumulation is done for every Doppler bin for every virtual antenna. Note that before accumulating, each factor in the sum is divided by 2^Ceil(Log2(numVirtualAntennas)). The purpose of doing this is to have the same CFAR threshold scale interpretation between the HWA and DSP versions of the DPU, this same interpretation allows for the convenience of configuring the same threshold scale for a downstream CFAR algorithm whether operating on the HWA or the DSP version of the doppler DPU. Refer to the description related to the conversion of CFAR threshold scale from user-friendly dB units to what is required for CFAR algorithm under <b>Summation</b> section in <a class="el" href="index.html#doppler_hwa_dpu">DopplerProcHWA</a> <br />
 Once all virtual antennas are processed for a given range bin, the accumulated array is transferred by EDMA to the detection matrix.<br />
<br />
 <b>Detailed block diagram for 3 TX 4 RX TDM-MIMO (no BPM)</b><br />
 The following figure depicts in detail the DPU implementation for the case of 3 TX and 4RX antennas (no BPM).</p>
<div class="image">
<img src="dsp_doppler_fft_3TX_4RX.png" alt="dsp_doppler_fft_3TX_4RX.png"/>
<div class="caption">
Doppler DPU implementation for 3 TX and 4 RX antennas</div></div>
<p>The following picture illustrates the ping/pong pattern for the case of 3 TX and 4 RX antennas. </p><div class="image">
<img src="dsp_doppler_fft_3TX_4RX_pingpong.png" alt="dsp_doppler_fft_3TX_4RX_pingpong.png"/>
<div class="caption">
Ping/pong pattern for the case of 3 TX and 4 RX antennas</div></div>
<h2><a class="anchor" id="doppler_bpmCfgNotes"></a>
BPM Scheme</h2>
<p>Similar to TDM-MIMO, in BPM scheme a frame consists of multiple blocks, each block consisting of 2 chirp intervals. However, unlike in TDM-MIMO where only one TX antenna active per chirp interval, two TX antennas are active in each chirp interval. This DPU only supports a BPM scheme with two TX antennas say A and B. In the even time slots (0, 2,...), both transmit antennas should be configured to transmit with positive phase i.e </p><pre class="fragment">(A,B) = (+,+) </pre><p> In the odd time slots (1, 3,...), the transmit antennas should be configured to transmit with phase<br />
 </p><pre class="fragment">(A,B) = (+,-) </pre><p> The BPM scheme is shown in the figure below where TX0 is used as antenna A and TX1 as antenna B.</p>
<div class="image">
<img src="bpm_antenna_cfg.png" alt="bpm_antenna_cfg.png"/>
<div class="caption">
BPM Scheme Antenna configuration</div></div>
<p> <b>BPM decoding</b><br />
 Let S1 and S2 represent chirp signals from two TX antennas. In time slot zero a combined signal Sa=S1+S2 is transmitted. Similarly in time slot one a combined signal Sb=S1-S2 is transmitted. Using the corresponding received signals, (S'a and S'b), at a specific received RX antenna, the components from the individual transmitters are separated out using<br />
</p><pre class="fragment">S'1=(S'a+S'b)/2 </pre><p> and </p><pre class="fragment">S'2=(S'a-S'b)/2 </pre><p> With simultaneous transmission on both TX antennas the total transmitted power per chirp interval is increased, and it can be shown that this translates to an SNR improvement of 3dB.<br />
</p>
<p><b>Order of the TX antennas in the BPM scheme</b><br />
 The BPM decoding will produce the virtual antenna array in the order (A, B), not (B, A), which will be used for AoA processing. Therefore, user must make sure that the (A, B) mapping to the physical transmit antennas corresponds to the intended virtual antenna order. For example, take the 6843 EVM antenna arrangement as shown in the figure below. Note that the DPU indexes the TX antennas as (TX0, TX1, TX2) which corresponds in the device to (TX1, TX2, TX3). <br />
 </p><div class="image">
<img src="coordinate_geometry_6843.png" alt="coordinate_geometry_6843.png"/>
<div class="caption">
6843 EVM antenna arrangement</div></div>
<p> Here two antennas TX1 and TX3 can create a virtual array of 8 antennas in the azimuth direction. In order to ensure correct virtual antenna processing for AoA calculations, after BPM decoding, the TX1 virtual antennas should precede the TX3 because the direction of spatial progression of RX antennas matches the direction of spatial progression of TX antennas when TX1 is before TX3 (post BPM decoding, the result should essentially be like TDM-MIMO). Therefore A=TX1 and B=TX3. In other words, BPM must be configured to do<br />
</p><pre class="fragment">(TX1,TX3) = (+,+) in even slots </pre><p> and<br />
</p><pre class="fragment">(TX1,TX3) = (+,-) in odd slots </pre><p> The opposite arrangement i.e<br />
</p><pre class="fragment">(TX3,TX1) = (+,+) in even slots </pre><p> and<br />
</p><pre class="fragment">(TX3,TX1) = (+,-) in odd slots </pre><p> will not work.<br />
<br />
 </p>
<h2><a class="anchor" id="doppler_bpmNotes"></a>
Doppler DPU changes when BPM is enabled</h2>
<p>When BPM is enabled the following changes are done in the Doppler DPU processing:<br />
 Doppler compensation and BPM decoding are done after the Doppler FFT. Note that the decoded data is not stored in the radar cube, therefore BPM decoding needs to be done again (on a much smaller set of samples) during the direction of arrival computation. The following figure shows the required changes in the Doppler processing. When BPM is enabled the fftOutBuf buffer is doubled in size to accommodate both Ping (TX0+TX1) and Pong (TX0-TX1) so that BPM can be decoded. The decoded data is written back to the fftOutBuf.</p>
<div class="image">
<img src="dsp_doppler_fft_2TX_4RX_BPM.png" alt="dsp_doppler_fft_2TX_4RX_BPM.png"/>
<div class="caption">
Doppler DPU implementation for 2 TX and 4 RX antennas and BPM enabled</div></div>
<p> <br />
<br />
 The following picture shows the ping/pong pattern for the case of 2 TX and 4 RX antennas (regardless if BPM is enabled or not). </p><div class="image">
<img src="dsp_doppler_fft_2TX_4RX_BPM_pingpong.png" alt="dsp_doppler_fft_2TX_4RX_BPM_pingpong.png"/>
<div class="caption">
Ping/pong pattern for the case of 2 TX and 4 RX antennas</div></div>
<p> <b>Exported APIs</b><br />
 DPU initialization is done through <a class="el" href="group___d_p_u___d_o_p_p_l_e_r_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0a95f2b9f2cc79cc8902aef063c35640">DPU_DopplerProcDSP_init</a>.<br />
<br />
 DPU configuration is done by <a class="el" href="group___d_p_u___d_o_p_p_l_e_r_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga84c68619bd57e566482b5ce4dcf50144">DPU_DopplerProcDSP_config</a>. The configuration can only be done after the DPU has been initialized. The configuration parameters are described in <a class="el" href="group___d_p_u___d_o_p_p_l_e_r_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gaa8ad8dbcdd96dd494a5232dc4bb36dba">DPU_DopplerProcDSP_Config</a>. <br />
<br />
 The DPU is executed by calling <a class="el" href="group___d_p_u___d_o_p_p_l_e_r_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gaf169bef9fef2a5104979f9ce55674565">DPU_DopplerProcDSP_process</a>. <br />
</p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
