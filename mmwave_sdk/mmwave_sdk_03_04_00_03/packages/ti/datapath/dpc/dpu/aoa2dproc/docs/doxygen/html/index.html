<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AOA2D AOA DPU using 2D angle FFT approach</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AOA2D AOA DPU using 2D angle FFT approach </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="aoa2d_dpu_intro_section"></a>
AOA2D AOA DPU</h1>
<p>This DPU implements angle of arrival (AoA) estimation using 2D angle FFT approach where 2D angle FFT is computed using HWA. This approach is applicable for TDM MIMO scheme with virtual antennas arranged in two dimensional array where the number of columns and rows are both greater than one.</p>
<p>DPU generates information about detected objects into two lists: 1) list with coordinates defined by <a class="el" href="struct_d_p_i_f___point_cloud_cartesian__t.html">DPIF_PointCloudCartesian_t</a> and 2) side information list defined by <a class="el" href="struct_d_p_i_f___point_cloud_side_info__t.html">DPIF_PointCloudSideInfo_t</a>. The DPU receives 1D-FFT Radar Cube matrix calculated by range processing DPU and the list of detected objects (<a class="el" href="struct_d_p_i_f___c_f_a_r_det_list__t.html">DPIF_CFARDetList_t</a>) which is assumed to be populated by previous CFAR algorithm processing.<br />
<br />
 </p>
<h1><a class="anchor" id="hwa_aoa2d_section_HWA-AOA"></a>
HWA-AOA-2D DPU (AoAProcHWA)</h1>
<p>This DPU implements angle of arrival (AoA) estimation using HWA and CPU. A high level data flow is illustrated in figure below.</p>
<div class="image">
<img src="hwa_aoa2d_top_level.png" alt="hwa_aoa2d_top_level.png"/>
<div class="caption">
HWA-AOA using 2D angle FFT approach - high level data flow</div></div>
<p> For each detected object the processing consists of the following:</p><ul>
<li>Recalculation of 2D-FFT antenna symbols corresponding to the objects range/doppler index, computed by HWA.</li>
<li>Rx channel phase/gain compensation.</li>
<li>Doppler compensation and symbol mapping into 2D matrix as input to 2D angle FFT.</li>
<li>2D-FFT calculation, computed by HWA.</li>
<li>Maximum peak search in the 2D FFT magnitude output, computed by HWA.</li>
<li>Peak grouping and selection of maximum peaks and X/Y/Z computation.</li>
</ul>
<p>The below figure depicts detailed DPU implementation.</p>
<div class="image">
<img src="hwa_aoa2d.png" alt="hwa_aoa2d.png"/>
<div class="caption">
HWA-AOA 2D angle FFT implementation (for 3 Tx antennas)</div></div>
<p> DPU processes data from the input CFAR detection list in a loop, two objects from the input list per loop. The processing is done in ping/pong manner so that the HWA processing, the EDMA transfers and the local core processing is done in parallel. Data processing is split in two paths, ping and pong path, one detected object per path. In each path processing is split between HWA and local core and it is divided in four stages: 2D-FFT (Doppler FFT) calculation by HWA, Doppler compensation by local core, 2D-FFT angle calculation and peak detection performed by HWA, and peak selection, and XYZ estimation by local core. These four stages include:</p><ol type="1">
<li>Calculation of the array of 2D-FFT Rx virtual antenna symbols as input to Azimuth FFT computation.<ol type="a">
<li>Input EDMA pages from radarCube memory to HWA memory the 1D-FFT data corresponding to the range index of the detected object. Note the input size limiting condition: <img class="formulaInl" alt="$N_{TxAnt}*N_{RxAnt}*N_{DopplerChirps}*sizeof(cmplx16ImRe\_t) \leq 16\;KB$" src="form_0.png"/></li>
<li>HWA calculates 2D FFT. Note the output size limiting condition: <img class="formulaInl" alt="$N_{TxAnt}*N_{RxAnt}*N_{DopplerBins}*sizeof(cmplx16ImRe\_t) \leq 32\;KB$" src="form_1.png"/></li>
<li>Output EDMA picks the data of the Doppler bin corresponding to the detected object's Doppler index from the above FFT output and copies into core local memory.</li>
</ol>
</li>
<li>CPU performs<ol type="a">
<li>Rx channel phase/gain compensation</li>
<li>Doppler compensation and symbol mapping into 2D matrix as input to 2D (azimuth/elevation) FFT. The diagram shows the input and output of symbol mapping corresponding to an example antenna pattern shown embedded near the output of the mapper.</li>
<li>Triggers EDMA to copy data back to HWA memory</li>
</ol>
</li>
<li>2D (azimuth/elevation) FFT calculation:<ol type="a">
<li>EDMA (triggered from previous step) copies 2D-FFT antenna symbols from local memory to HWA memory.</li>
<li>HWA calculates azimuth FFT (complex output).</li>
<li>HWA calculates elevation FFT (complex output) on azimuth FFT outputs.</li>
<li>HWA creates list of peaks as follows:<ol type="i">
<li>When multi-object peak search is enabled, CFAR in HWA is run for each azimuth row to create a list of detected peaks.</li>
<li>When multi-object peak search is disabled, statistics block in HWA is run for each azimuth row to create a list of peaks.</li>
</ol>
</li>
<li>EDMA copies HWA detected peaks from HWA memory to the local core memory.</li>
</ol>
</li>
<li>CPU selects the highest peak/peaks, and performs the final x/y/z calculation. The calculated data of detected objects are appended to the output lists.</li>
</ol>
<p>One HWA loop iteration processes 2 detected objects. If the number of detected objects is odd, a dummy one is appended at the end of the list of detected points. It is processed by HWA, but at the end not appended to the final list.</p>
<p>The following figure shows the local core processing flow including two objects per loop.</p>
<div class="image">
<img src="hwa_aoa_flow_chart.png" alt="hwa_aoa_flow_chart.png"/>
<div class="caption">
Local core processing flow</div></div>
<p> The HWA runs in parallel with local core and EDMA transfers, processing data within its loop in the following order: ping path 2D-FFT, pong path 2D-FFT, ping path 2D-azimuth/elevation FFT, pong path 2D-azimuth/elevation FFT. This is illustrated in the timing diagram in figure below.</p>
<div class="image">
<img src="hwa_aoa_timing_diagram.png" alt="hwa_aoa_timing_diagram.png"/>
<div class="caption">
Timing diagram example: processing 5 detected objects</div></div>
<p> The scheme uses four EDMA physical channels, two EDMA channels to input data from the local core memory to HWA, one channel per path, and two EDMA channels to output data from HWA memory to the local core memory, one EDMA channel per path. The scheme also uses 16 EDMA param sets programmed for data transfer and HWA triggering. HWA programming is done by up to 14 HWA param sets. The usage of EDMA and HWA param sets is described in the following two figures, the first of two showing the usage when the multi-object peak detection is enabled, and the second of two, when the multi-object peak detection is disabled. Note the occurrence of the HWA dummy param, following the HWA CFAR param. This is necessary because of the HWA register read issue, (the register read is unreliable when the state machine is running), so the HWA dummy param is inserted there to pause the HWA execution while the register with the number of CFAR detections is read out by EDMA which immediately after the read triggers the continuation of the HWA execution. In the case when multi-object peak detection is disabled, the HWA dummy param has pure dummy role. Note that EDMA input to HWA in the first stage is AB-Synchronized type transfer, while all other EDMAs in the scheme are A-Synchronized type transfers. Since the radar cube is aligned to 4 byte boundary, none of these transfers fall under the EDMA 4K boundary problem.</p>
<div class="image">
<img src="hwa_aoa_param_sets.png" alt="hwa_aoa_param_sets.png"/>
<div class="caption">
EDMA and HWA param set usage for multi peak detection mode</div></div>
 <div class="image">
<img src="hwa_aoa_param_sets_single_peak.png" alt="hwa_aoa_param_sets_single_peak.png"/>
<div class="caption">
EDMA and HWA param set usage for single peak detection mode</div></div>
 <h2><a class="anchor" id="hwa_aoa2d_Azimuth_heat_map"></a>
Azimuth heatmap preparation</h2>
<p>When the <a class="el" href="struct_d_p_u___ao_a_proc___dynamic_local_config__t.html#a5e2b9345cd835ca4e0932822cc9f4858">DPU_AoAProc_DynamicLocalConfig::prepareRangeAzimuthHeatMap</a> is enabled this DPU generates data for computing azimuth/elevation heat-map (e.g for visualization purposes). The exported data is a 2D array as x[number of range bins][number of virtual antennas] with elements being of type of type cmplx16ImRe_t. The elements are 2D FFT symbols corresponding to zero Doppler bin. The following figure depicts data generation for azimuth heat-map visualization. Here, as well, none of the transfers fall under the EDMA 4K boundary problem.</p>
<div class="image">
<img src="hwa_aoa_azimuth_heatmap.png" alt="hwa_aoa_azimuth_heatmap.png"/>
<div class="caption">
HWA-AOA implementation</div></div>
 <h1><a class="anchor" id="hwa_aoa2d_api_section"></a>
AoAProcHWA APIs</h1>
<ul>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9c3e52c665e4e1d501ee8ed61f881746">DPU_AoAProcHWA_init</a> - DPUs initialization function.</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9e559182530f1b8d5b770eddc1972cba">DPU_AoAProcHWA_config</a> - DPUs configuration function. The configuration can only be done after the DPU has been initialized using <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9c3e52c665e4e1d501ee8ed61f881746">DPU_AoAProcHWA_init</a>. If the parameters used by this DPU do not change from one frame to the next, this function can be called only once, for the first frame, otherwise it has to be called before each <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga73a8300a9bc8f3270fbd16384f9f287f">DPU_AoAProcHWA_process</a>.</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga73a8300a9bc8f3270fbd16384f9f287f">DPU_AoAProcHWA_process</a> - DPUs processing function performs AoA estimation of detected objects in the given frame. This processing can only be done after the DPU has been configured.</li>
<li><p class="startli"><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga27bd186d59e946b1154233daa385e873">DPU_AoAProcHWA_control</a> - DPUs control function. It processes following messages from DPC:</p><ul>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03a14bbb6dcb894addb4129913569fcceda">DPU_AoAProcHWA_Cmd_FovAoACfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03a9de4da31c858ab558b0ac0c44c9f8f5b">DPU_AoAProcHWA_Cmd_MultiObjBeamFormingCfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03a0244a1c7e048283f4d3c2e69c90099ab">DPU_AoAProcHWA_Cmd_CompRxChannelBiasCfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03aa8173743c13e52505e938b0836320904">DPU_AoAProcHWA_Cmd_PrepareRangeAzimuthHeatMap</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03a0799dbe80bf53a9737fbb80bd3da8c51">DPU_AoAProcHWA_Cmd_ExtMaxVelocityCfg</a></li>
</ul>
<p class="startli">Full API details can be seen at <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l.html">aoaProc DPU External</a></p>
</li>
</ul>
<p><br />
<br />
<br />
</p>
<h2><a class="anchor" id="hwa_aoa2d_Sect_Antenna_geometry"></a>
Antenna Geometry Definition</h2>
<p>Antenna geometry is defined by two arrays of structures of type <a class="el" href="struct_a_n_t_d_e_f___ant_offset__t.html">ANTDEF_AntOffset_t</a> which hold the antenna position offsets, in multiples of <img class="formulaInl" alt="$ \lambda/2 $" src="form_2.png"/>, in azimuth and elevation direction. Antenna offsets for AoP and standard EVM boards is illustrated in figure below. The AOP antenna geometry structures are defined in <a class="el" href="antenna__geometry_8c.html">antenna_geometry.c</a>.</p>
<div class="image">
<img src="antenna_geometries.png" alt="antenna_geometries.png"/>
<div class="caption">
Examples of antenna geometries</div></div>
 <h2><a class="anchor" id="hwa_aoa2d_Sect_SymbolMapping_dopplerComp"></a>
Symbol Mapping, Scaling and Doppler Compensation</h2>
<p>Symbol mapping and Doppler compensation function (<a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gae478b3921603821c7d520a902f16d748">AoAProcHWA_dopplerCompensation</a>) is performed by local core after the Rx channel phase/gain compensation.</p>
<h3><a class="anchor" id="hwa_aoa2d_Sect_SymbolMapping"></a>
Symbol Mapping</h3>
<p>The 2D FFT antenna symbols are mapped into 2D matrix whose size and shape depend on the order and the number of tx antennas used in TDM MIMO scheme. The following configurations are supported: 4Rx/3Tx, 4Rx/2Tx, and 4Rx/1Tx with any Tx antenna order. Figure below shows example of antenna mapping.</p>
<div class="image">
<img src="ant_mapping_to_angle_fft_input.png" alt="ant_mapping_to_angle_fft_input.png"/>
<div class="caption">
Antenna mapping to angle 2D-FFT input matrix</div></div>
 <h3><a class="anchor" id="hwa_aoa2d_Sect_Scaling"></a>
Scaling</h3>
<p>The automatic scaling is introduced because of the HWA CFAR peak grouping issue in xwr18xx device: the peak grouping feature within HWA CFAR will fail to export the valid peak when it consists of 2 or more consecutive identical samples at the peak position. When the signal level is small, the magnitude of the 2D-FFT output is also small, and since the 2D output surface is smooth, the chance is increased that the output values around the peak position will have the same value, and the peak would be missed. Because of this issue, a gain is applied to the input symbols to reduce the chance of two identical consecutive values at the peak position. The gain is calculated by function <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga07ab0306c710ccb5a9c8969124737e62">AoAProcHWA_3DFFTGainCalc</a> such that the input symbols have averaged rms value of 1000. With this input level, the chance of missing peaks is reduced. Note this peak grouping issue is fixed in HWA for xwr68xx ES2.0 device but the algorithm here is common across devices and does automatic scaling regardless of the device/HWA version.</p>
<h3><a class="anchor" id="hwa_aoa2d_Sect_dopplerComp"></a>
Doppler Compensation</h3>
<p>Doppler compensation is compensation for the Doppler phase shift on virtual Rx antenna symbols. In case of 2Tx TDM MIMO scheme, the second set of Rx symbols is rotated by half of the estimated Doppler phase shift. The estimated Doppler phase shift is the phase shift between subsequent chirps corresponding to the same Tx antenna. In case of 3Tx TDM MIMO scheme, the second set of Rx symbols is rotated by 1/3 of the estimated Doppler phase shift, while the third set of Rx symbols is rotated by 2/3 of the estimated Doppler phase shift. Refer to figure below. Note that the 2D antenna array is viewed from sensor towards the scene. <a class="anchor" id="hwa_aoa2d_Figure_doppler"></a> </p><div class="image">
<img src="doppler_compensation.png" alt="doppler_compensation.png"/>
<div class="caption">
Figure_doppler: Doppler Compensation</div></div>
 <h2><a class="anchor" id="hwa_aoa2d_Sect_Peak_detection"></a>
Peak selection in 2D azimuth/elevation FFT Output</h2>
<p>The azimuth/elevation angle estimation is based on the finding of the peak position, azimuth index and elevation index, in the 2D angle FFT magnitude output. The 2D FFT is computed by HWA using the same size (<a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_e_f_i_n_i_t_i_o_n_s.html#ga46a73bc24d553f6769fae276ee81ec9e">DPU_AOAPROCHWA_NUM_ANGLE_BINS</a>) in azimuth and elevation direction. The peak search is implemented by combined search by HWA and local core. Two approaches are implemented:</p><ul>
<li>When multi-object peak detection is disabled, peak search by HWA statistics block followed by local core processing.</li>
<li>When multi-object peak detection is enabled, peak search by HWA CFAR followed by local core processing.</li>
</ul>
<p>In both approaches, HWA produces the initial list of detected peaks from 2D FFT output, and then the local core completes the peak search and outputs the the final list of detected peaks. The final number of detected peaks per range/Doppler index pair is limited to <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_e_f_i_n_i_t_i_o_n_s.html#ga62c4c7612f28cd4e27454192a720a8e3">DPU_AOAPROCHWA_MAX_NUM_EXPORTED_TARGETS_PER_RANGE_DOPPLER_PT</a>.</p>
<h3><a class="anchor" id="hwa_aoa2d_Sect_HWA_Max_Peak_Search"></a>
Maximum peak search using HWA statistics block</h3>
<p>When multi-object peak detection is disabled, (when <a class="el" href="struct_d_p_u___ao_a_proc___dynamic_local_config__t.html#adece286850fa05c75b5db451e6d68d9b">DPU_AoAProc_DynamicLocalConfig::multiObjBeamFormingCfg</a> is disabled), the HWA calculates the peak index in azimuth direction for every elevation bin. The output is a list of length <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_e_f_i_n_i_t_i_o_n_s.html#ga46a73bc24d553f6769fae276ee81ec9e">DPU_AOAPROCHWA_NUM_ANGLE_BINS</a> with elements defined by <a class="el" href="struct_d_p_u___ao_a_proc_h_w_a___hwa_max_output__t.html">DPU_AoAProcHWA_HwaMaxOutput_t</a>, where the element's field maxInd represents the azimuth index position of the maximum peak, while the element's index in the list represents the elevation position of the peak.</p>
<p>The local core then searches for the maximum peak in the list, <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga2390f03d8753b755f0f7ae7b9ab1881a">AoAProcHWA_findSinglePeak</a> and produces the azimuth/elevation index pair of the maximum peak in the 2D FFT output.</p>
<h3><a class="anchor" id="hwa_aoa2d_Sect_CFAR_Max_Peak_Search"></a>
Maximum peaks search using HWA CFAR</h3>
<p>When multi-object peak detection is enabled, the HWA CFAR engine is used to create initial list of peaks, defined by <a class="el" href="struct_d_p_u___ao_a_proc_h_w_a___cfar_det_output__t.html">DPU_AoAProcHWA_CfarDetOutput_t</a> . The CFAR runs in azimuth direction for every elevation bin producing few peaks per elevation bin. The relevant CFAR configuration parameters are:</p><ul>
<li>detection threshold = 1,</li>
<li>guard length = 0,</li>
<li>noise window = 2,</li>
<li>noise shift = 2 (average of 4 neighbor samples)</li>
<li>circular search is enabled,</li>
<li>peak grouping is enabled,</li>
<li>CFAR runs in azimuth direction, iterating in elevation direction,</li>
<li>Detected peaks are exported in the output detection list <a class="el" href="struct_d_p_u___ao_a_proc_h_w_a___cfar_det_output__t.html">DPU_AoAProcHWA_CfarDetOutput_t</a> where the field cellidx represents azimuth index, and the field iterNum represents elevation index.</li>
</ul>
<p>Figure below illustrates CFAR running along one azimuth line shown in red on the 2D FFT output surface. The middle figure shows the cell under test (CUT) and the noise. The figure on the right shows the difference between CUT and noise. Since the threshold is set to 1, all cells with the difference greater than zero will be detected by CFAR, but with the peak grouping enabled, only 3 peaks are reported by CFAR (black circles in the middle figure). The complete output detection list of peaks is illustrated in figure below, with detected peaks shown in red. Note that since the number of input FFT symbols is not more than 4, and the FFT size being 64, no more than 4 peaks would be expected per row.</p>
<div class="image">
<img src="cfar_peak_search.png" alt="cfar_peak_search.png"/>
<div class="caption">
Example: Peak search using HWA CFAR</div></div>
<p> Figure below illustrates all CFAR detected peaks in the example above.</p>
<div class="image">
<img src="angle_2dfft_and_cfar_peaks.png" alt="angle_2dfft_and_cfar_peaks.png"/>
<div class="caption">
Example: Peak search using HWA CFAR showing all CFAR detected peaks</div></div>
 <h3><a class="anchor" id="hwa_aoa2d_Sect_Peak_Grouping"></a>
Peak grouping on the local core</h3>
<p>When multi-object detection per range/Doppler bin is enabled, the peak grouping on the local core is performed by two functions:</p><ul>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gadbaeed7fe59c0c87225d109678b4dbfe">AoAProcHWA_peakGrouping</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga750384f691f8141649486417b8837c76">AoAProcHWA_SelectMaxPeaks</a></li>
</ul>
<p>When multi-object detection per range/doppler bin is disabled, the maximum peak selection is performed by</p><ul>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga2390f03d8753b755f0f7ae7b9ab1881a">AoAProcHWA_findSinglePeak</a></li>
</ul>
<p>The peak grouping function <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gadbaeed7fe59c0c87225d109678b4dbfe">AoAProcHWA_peakGrouping</a> performs additional peak grouping on the CFAR list of detected peaks. It eliminates neighboring peaks occurring in the CFAR consecutive iterations and selects only the highest peaks. Also at the end, besides the maximum peak, it eliminates any peak below specified threshold relative to the maximum peak. The algorithm scans the CFAR detected list <a class="el" href="struct_d_p_u___ao_a_proc_h_w_a___cfar_det_output__t.html">DPU_AoAProcHWA_CfarDetOutput_t</a> and for each detected peak it forms a kernel of size 5x5, fills the kernel with peaks from the input list, and it qualifies the peak if it is greater than all the peaks found in the kernel. The kernel size could have been set to 3x3, but because of the HWA peak grouping issue in xwr18xx (bug fixed in xwr68xx ES2.0), it is set to 5x5 to avoid breaking the sequences of neighboring peaks. The function outputs the number of selected peaks, and the index list of selected peaks pointing to the input list. The size of output index list is limited to <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_e_f_i_n_i_t_i_o_n_s.html#ga87f9673eb7c80796eef72762f1685fee">DPU_AOAPROCHWA_MAX_NUM_GROUPED_TARGETS_PER_RANGE_DOPPLER_PT</a> .</p>
<p>In the example above, the peak grouping function would initially select only 7 peaks, labeled A to G in the figure above. Notice that the sequences of peaks circularly wrap around in azimuth or elevation direction. At the end, the highest peak, labeled A, along with any other peaks greater than the provided threshold will be marked in the output list.</p>
<p>The selection of N highest peaks is performed by <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga750384f691f8141649486417b8837c76">AoAProcHWA_SelectMaxPeaks</a> . This function sorts the selected peaks and copies the specified number of highest peaks to the output list of type <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga6afde09e6cb64e76d8844586b0e22924">DPU_AoAProcHWA_CfarDetOutput</a>. The number highest peaks is set by <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_e_f_i_n_i_t_i_o_n_s.html#ga62c4c7612f28cd4e27454192a720a8e3">DPU_AOAPROCHWA_MAX_NUM_EXPORTED_TARGETS_PER_RANGE_DOPPLER_PT</a> .</p>
<p>When multi peak grouping is is disabled, the function <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga2390f03d8753b755f0f7ae7b9ab1881a">AoAProcHWA_findSinglePeak</a> searches for the maximum peak in the list of peaks provided by HWA statistics module. The input list is of type <a class="el" href="struct_d_p_u___ao_a_proc_h_w_a___hwa_max_output__t.html">DPU_AoAProcHWA_HwaMaxOutput_t</a>. The length of the list is equal to elevation FFT size <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_e_f_i_n_i_t_i_o_n_s.html#ga46a73bc24d553f6769fae276ee81ec9e">DPU_AOAPROCHWA_NUM_ANGLE_BINS</a>. The function searches for the single maximum peak, constructs the azimuth and elevation index and fills the maximum peak data to the output list of type <a class="el" href="struct_d_p_u___ao_a_proc_h_w_a___cfar_det_output__t.html">DPU_AoAProcHWA_CfarDetOutput_t</a>.</p>
<h2><a class="anchor" id="hwa_aoa2d_dataXYZ"></a>
Data Path - Direction of Arrival Estimation (x,y,z)</h2>
<p>The (x,y,z) coordinate computation per detected object is performed by <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga50a9247cec745224f6ae7c75ce4512e0">AoAProcHWA_XYZestimationAoA2D</a>. The function also eliminates the objects outside of the specified azimuth and elevation field of view. <a class="anchor" id="hwa_aoa2d_Figure_geometry"></a> </p><div class="image">
<img src="coordinate_geometry.png" alt="coordinate_geometry.png"/>
<div class="caption">
Figure A: Coordinate Geometry</div></div>
<p> <br />
<a class="anchor" id="hwa_aoa2d_Figure_wz"></a> </p><div class="image">
<img src="coordinate_geometry_wz.png" alt="coordinate_geometry_wz.png"/>
<div class="caption">
Figure wz</div></div>
<p> <br />
<a class="anchor" id="hwa_aoa2d_Figures_wx"></a> </p><div class="image">
<img src="coordinate_geometry_wx.png" alt="coordinate_geometry_wx.png"/>
<div class="caption">
Figures wx</div></div>
<p> <a class="el" href="index.html#hwa_aoa2d_Figure_geometry">hwa_aoa2d_Figure_geometry</a> shows orientation of (x,y,z) axes with respect to the sensor/antenna positions. The objective is to estimate the (x,y,z) coordinates of each detected object. <img class="formulaInl" alt="$w_x$" src="form_3.png"/> is the phase difference between consecutive receive antennas in azimuth direction of the FFT 2D input array and <img class="formulaInl" alt="$w_z$" src="form_4.png"/> is the phase difference between consecutive receive antennas in elevation direction of the FFT 2D input array. The phases for each antenna are shown in the <a class="el" href="index.html#hwa_aoa2d_Figure_doppler">hwa_aoa2d_Figure_doppler</a>. We assume that the phase shifts due to Doppler are already compensated i.e. <img class="formulaInl" alt="$\delta=0$" src="form_5.png"/>. <a class="el" href="index.html#hwa_aoa2d_Figure_wz">hwa_aoa2d_Figure_wz</a> shows that the distance AB which represents the relative distance between wavefronts intersecting consecutive antennas in elevation direction is <img class="formulaInl" alt="$AB = \frac{\lambda}{2} \sin (\phi)$" src="form_6.png"/>. Therefore <img class="formulaInl" alt="$W_z = \frac{2\pi}{\lambda} \cdot AB$" src="form_7.png"/>, therefore <img class="formulaInl" alt="$W_z = \pi \sin (\phi)$" src="form_8.png"/>. <a class="el" href="index.html#hwa_aoa2d_Figures_wx">hwa_aoa2d_Figures_wx</a> show that distance CD which represents the relative distance between wavefronts intersecting consecutive antennas in azimuth direction is <img class="formulaInl" alt="$CD = \frac{\lambda}{2} \sin (\theta) \cos (\phi)$" src="form_9.png"/> Therefore <img class="formulaInl" alt="$w_x = \frac{2\pi}{\lambda} \cdot CD$" src="form_10.png"/>, therefore <img class="formulaInl" alt="$w_x = \pi \sin (\theta) \cos (\phi)$" src="form_11.png"/>.</p>
<p>If <img class="formulaInl" alt="$k_{azim},k_{elev}$" src="form_12.png"/> is the index pair of the maximum peak in <img class="formulaInl" alt="$N{\times}N$" src="form_13.png"/> 2D-FFT represented as signed indices in range <img class="formulaInl" alt="$[-\frac{N}{2}, \frac{N}{2}-1]$" src="form_14.png"/>, then <img class="formulaInl" alt="$ w_x $" src="form_15.png"/> will be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_x = \frac{2\pi}{N}k_{azim} \]" src="form_16.png"/>
</p>
<p>and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_z= \frac{2\pi}{N}k_{elev} \]" src="form_17.png"/>
</p>
<p>Calculate range (in meters) as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R=k_r\frac{c \cdot F_{SAMP}}{2 \cdot S \cdot N_{FFT}} \]" src="form_18.png"/>
</p>
<p> where, <img class="formulaInl" alt="$c$" src="form_19.png"/> is the speed of light (m/sec), <img class="formulaInl" alt="$k_r$" src="form_20.png"/> is range index, <img class="formulaInl" alt="$F_{SAMP}$" src="form_21.png"/> is the sampling frequency (Hz), <img class="formulaInl" alt="$S$" src="form_22.png"/> is chirp slope (Hz/sec), <img class="formulaInl" alt="$N_{FFT}$" src="form_23.png"/> is 1D FFT size. Based on above calculations of <img class="formulaInl" alt="$R$" src="form_24.png"/>, <img class="formulaInl" alt="$w_x$" src="form_3.png"/> and <img class="formulaInl" alt="$w_z$" src="form_4.png"/>, the <img class="formulaInl" alt="$(x,y,z)$" src="form_25.png"/> position of the object can be calculated as seen in the <a class="el" href="index.html#hwa_aoa2d_Figure_geometry">hwa_aoa2d_Figure_geometry</a>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = R\cos(\phi)\sin(\theta) = R\frac{w_x}{\pi}, \;\;\;\;\; z = R\sin(\phi) = R\frac{w_z}{\pi},\;\;\;\;\; y = \sqrt{R^2-x^2-z^2} \]" src="form_26.png"/>
</p>
<p> The computed <img class="formulaInl" alt="$(x,y,z)$" src="form_25.png"/> along with the Doppler value for each detected object are populated in the output list, structured as <a class="el" href="struct_d_p_i_f___point_cloud_cartesian__t.html">DPIF_PointCloudCartesian_t</a>.</p>
<h2><a class="anchor" id="hwa_aoa2d_fovSubSection"></a>
Elimination of detected objects based on FoV limits</h2>
<p>The AoA DPU filters out detected objects whose azimuth, <img class="formulaInl" alt="$\theta$" src="form_27.png"/>, and elevation, <img class="formulaInl" alt="$\phi$" src="form_28.png"/>, angles are not within configured FoV limits. The DPU receives the following FoV parameters:</p>
<p><img class="formulaInl" alt="$\phi_{min},\;\phi_{max},$" src="form_29.png"/> - elevation angle FoV limits</p>
<p><img class="formulaInl" alt="$\theta_{min},\;\theta_{max}$" src="form_30.png"/> - azimuth angle FoV limits</p>
<p>The DPU computes <img class="formulaInl" alt="$W_z$" src="form_31.png"/> and <img class="formulaInl" alt="$W_x$" src="form_32.png"/> directly from azimuth FFT output data, where</p>
<p><img class="formulaInl" alt="$W_z = w_z/\pi$" src="form_33.png"/></p>
<p><img class="formulaInl" alt="$W_x = w_x/\pi$" src="form_34.png"/></p>
<p>From equations in previous section the following holds</p>
<p><img class="formulaInl" alt="$W_z = \sin(\phi)$" src="form_35.png"/></p>
<p><img class="formulaInl" alt="$W_x = \cos(\phi) \sin(\theta)$" src="form_36.png"/></p>
<p>Because sine is a monotonic increasing function in the maximum possible range of -90 deg, 90 deg, the elevation angle <img class="formulaInl" alt="$\phi$" src="form_28.png"/> FoV limits can be checked on <img class="formulaInl" alt="$W_z$" src="form_31.png"/> as follows</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sin(\phi_{min}) \leq W_z \leq \sin(\phi_{max}) \]" src="form_37.png"/>
</p>
<p>Since <img class="formulaInl" alt="$W_x$" src="form_32.png"/> is not monotonic in <img class="formulaInl" alt="$\phi$" src="form_28.png"/> but monotonic on <img class="formulaInl" alt="$\theta$" src="form_27.png"/>, the azimuth angle <img class="formulaInl" alt="$\theta$" src="form_27.png"/> limits can be checked by checking <img class="formulaInl" alt="$W_x$" src="form_32.png"/> after computing the <img class="formulaInl" alt="$\cos(\phi)$" src="form_38.png"/> on the measured <img class="formulaInl" alt="$\phi$" src="form_28.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \cos(\phi)\sin(\theta_{min}) \leq W_x \leq \cos(\phi) \sin(\theta_{max}) \]" src="form_39.png"/>
</p>
<p>where <img class="formulaInl" alt="$\cos(\phi) = \sqrt{1 - \sin(\phi)^2} = \sqrt{1 - W_z^2}$" src="form_40.png"/>. Note that the terms <img class="formulaInl" alt="$\sin(\phi_{min})$" src="form_41.png"/>, <img class="formulaInl" alt="$\sin(\phi_{max})$" src="form_42.png"/>, <img class="formulaInl" alt="$\sin(\theta_{min})$" src="form_43.png"/> and <img class="formulaInl" alt="$\sin(\theta_{max})$" src="form_44.png"/> are precomputed during configuration time and stored in the dpu's instance (<a class="el" href="struct_d_p_u___ao_a_proc__fov_aoa_local_cfg__t.html">DPU_AoAProc_fovAoaLocalCfg_t</a>) to be used in the real-time limit checks above. The brute-force method of checking limits on <img class="formulaInl" alt="$\phi$" src="form_28.png"/> and <img class="formulaInl" alt="$\theta$" src="form_27.png"/> directly requires computing these, which involves two sin inverses, one cosine and one division which are computationally more expensive than the above method. </p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
