<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AOA DPU</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AOA DPU </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="aoaprocdpu_intro_section"></a>
AoA DPU</h1>
<h2>Description </h2>
<p>This DPU implements angle of arrival (AoA) estimation. It generates information about detected objects into two lists: 1) list with coordinates defined by <a class="el" href="struct_d_p_i_f___point_cloud_cartesian__t.html">DPIF_PointCloudCartesian_t</a> and 2) side information list defined by <a class="el" href="struct_d_p_i_f___point_cloud_side_info__t.html">DPIF_PointCloudSideInfo_t</a>. The DPU receives 1D-FFT Radar Cube matrix calculated by range processing DPU and the list of detected objects (<a class="el" href="struct_d_p_i_f___c_f_a_r_det_list__t.html">DPIF_CFARDetList_t</a>) which is assumed to be populated by previous CFAR algorithm processing.<br />
<br />
 The AoA DPU is available in two distinct implementations:</p>
<table class="doxtable">
<tr>
<th align="left">DPU Implementation </th><th align="left">Runs on cores </th><th align="left">Uses HWA  </th></tr>
<tr>
<td align="left">AoAProcHWA </td><td align="left">R4F or DSP </td><td align="left">Yes </td></tr>
<tr>
<td align="left">AoAProcDSP </td><td align="left">DSP </td><td align="left">No </td></tr>
</table>
<p><br />
 This document is organized as follows:<br />
 </p><table class="doxtable">
<tr>
<th align="left">Starting Section </th><th align="left">Description  </th></tr>
<tr>
<td align="left"><a class="el" href="index.html#HWA-AOA-start">HWA-AOA-start</a> </td><td align="left">Start of the sections describing the AoAProcHWA DPU. It covers DPU implementation details. </td></tr>
<tr>
<td align="left"><a class="el" href="index.html#DSP-AOA-start">DSP-AOA-start</a> </td><td align="left">Start of the sections describing the AoAProcDSP DPU. It covers DPU implementation details. </td></tr>
<tr>
<td align="left"><a class="el" href="index.html#HWA-DSP-Common-start">HWA-DSP-Common-start</a> </td><td align="left">Start of the sections that are common for AoAProcDSP and AoAProcHWA. It covers Doppler compensation, XYZ estimation/geometry and FoV configuration. </td></tr>
</table>
<p><br />
<br />
</p>
<p><a class="anchor" id="HWA-AOA-start"></a></p>
<h1><a class="anchor" id="section_HWA-AOA"></a>
HWA-AOA DPU (AoAProcHWA)</h1>
<h2><a class="anchor" id="section_AOA_Description"></a>
Description</h2>
<p>This DPU implements angle of arrival (AoA) estimation using HWA and CPU. A high level data flow is illustrated in figure below.</p>
<div class="image">
<img src="hwa_aoa_top_level.png" alt="hwa_aoa_top_level.png"/>
<div class="caption">
HWA-AOA high level data flow</div></div>
<p> The following figure depicts detailed DPU implementation. DPU processes data from the input CFAR detection list in a loop, two objects from the input list per loop. The processing is done in ping/pong manner so that the HWA processing, the EDMA transfers and the local core processing is done in parallel. Data processing is split in two paths, ping and pong path, one detected object per path. In each path processing is split between HWA and local core and it is divided in four stages: 2D-FFT calculation by HWA, Doppler compensation by local core, 3D-FFT calculation by HWA and XYZ estimation by local core. These four stages include:</p><ol type="1">
<li>Calculation of the array of 2D-FFT Rx virtual antenna symbols as input to Azimuth FFT computation.<ol type="a">
<li>Input EDMA pages from radarCube memory to HWA memory the 1D-FFT data corresponding to the range index of the detected object. Note the input size limiting condition: <img class="formulaInl" alt="$N_{TxAnt}*N_{RxAnt}*N_{DopplerChirps}*sizeof(cmplx16ImRe\_t) \leq 16\;KB$" src="form_0.png"/></li>
<li>HWA calculates 2D FFT. Note the output size limiting condition: <img class="formulaInl" alt="$N_{TxAnt}*N_{RxAnt}*N_{DopplerBins}*sizeof(cmplx16ImRe\_t) \leq 32\;KB$" src="form_1.png"/></li>
<li>Output EDMA picks the data of the Doppler bin corresponding to the detected object's Doppler index from the above FFT output and copies into core local memory.</li>
</ol>
</li>
<li>CPU performs<ol type="a">
<li>Rx channel phase/gain compensation</li>
<li>Doppler compensation</li>
<li>Triggers EDMA to copy data back to HWA memory</li>
</ol>
</li>
<li>Azimuth FFT calculation:<ol type="a">
<li>EDMA copies 2D-FFT antenna symbols from local memory to HWA memory,</li>
<li>HWA calculates azimuth FFT (complex output) on azimuth Tx antennas,</li>
<li>HWA calculates azimuth FFT (complex output) on elevation Tx antennas,</li>
<li>HWA calculates Magnitude square of the FFT output of azimuth Tx antennas,</li>
<li>EDMA copies magnitude squares from HWA memory to the local core memory</li>
</ol>
</li>
<li>Final azimuth and elevation estimation and x/y/z calculation performed by local core. The calculated data of detected object is appended to the output lists.</li>
</ol>
<p>One HWA loop iteration processes 2 detected objects. (If the number of detected objects is odd, a dummy one is appended at the end of the list of detected points.)</p>
<div class="image">
<img src="hwa_aoa.png" alt="hwa_aoa.png"/>
<div class="caption">
HWA-AOA implementation (for 3 Tx antennas)</div></div>
<p> The following figure shows the local core processing flow including two objects per loop. The HWA runs in parallel, processing data within its loop in the following order: ping path 2D-FFT, pong path 2D-FFT, ping path 3D-FFTs, pong path 3D-FFTs. This is illustrated in the timing diagram shown in figure below.</p>
<div class="image">
<img src="hwa_aoa_flow_chart.png" alt="hwa_aoa_flow_chart.png"/>
<div class="caption">
Local core processing flow</div></div>
 <div class="image">
<img src="hwa_aoa_timing_diagram.png" alt="hwa_aoa_timing_diagram.png"/>
<div class="caption">
Timing diagram example: processing 5 detected objects</div></div>
<p> The scheme uses four EDMA physical channels, two EDMA channels to input data from the local core memory to HWA, one channel per path, and two EDMA channels to output data from HWA memory to the local core memory, one EDMA channel per path. The scheme also uses 12 EDMA param sets programmed for data transfer and HWA triggering. HWA programming is done by up to 12 HWA Param sets. The usage of EDMA and HWA param set is described in figure below. Note that EDMA Input to HWA in the first stage is AB-Synchronized type transfer, while all other EDMAs in the scheme are A-Synchronized type transfers. Since the radar cube is aligned to 4 byte boundary, none of these transfers fall under the EDMA 4K boundary problem. </p><div class="image">
<img src="hwa_aoa_param_sets.png" alt="hwa_aoa_param_sets.png"/>
<div class="caption">
EDMA and HWA param set usage</div></div>
 <h2><a class="anchor" id="Azimuth_heat_map"></a>
Azimuth heatmap preparation</h2>
<p>In addition to AoA estimation, this DPU also generates data for computing azimuth heat-map (e.g for visualization purposes), this data is 2D FFT of the phase compensated Doppler bin 0 (static objects) output of each of the range bins. The following figure depicts data generation for azimuth heat-map visualization. Here, as well none of the trunfers fall under the EDMA 4K boundary problem.</p>
<div class="image">
<img src="hwa_aoa_azimuth_heatmap.png" alt="hwa_aoa_azimuth_heatmap.png"/>
<div class="caption">
Data processing for azimuth heat-map visualization</div></div>
<h1><a class="anchor" id="api_section"></a>
AoAProcHWA APIs</h1>
<ul>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9c3e52c665e4e1d501ee8ed61f881746">DPU_AoAProcHWA_init</a> - DPUs initialization function.</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9e559182530f1b8d5b770eddc1972cba">DPU_AoAProcHWA_config</a> - DPUs configuration function. The configuration can only be done after the DPU has been initialized using <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9c3e52c665e4e1d501ee8ed61f881746">DPU_AoAProcHWA_init</a>. If the parameters used by this DPU do not change from one frame to the next, this function can be called only once, for the first frame, otherwise it has to be called before each <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga73a8300a9bc8f3270fbd16384f9f287f">DPU_AoAProcHWA_process</a>.</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga73a8300a9bc8f3270fbd16384f9f287f">DPU_AoAProcHWA_process</a> - DPUs processing function performs AoA estimation of detected objects in the given frame. This processing can only be done after the DPU has been configured.</li>
<li><p class="startli"><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga27bd186d59e946b1154233daa385e873">DPU_AoAProcHWA_control</a> - DPUs control function. It processes following messages from DPC:</p><ul>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03a14bbb6dcb894addb4129913569fcceda">DPU_AoAProcHWA_Cmd_FovAoACfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03a9de4da31c858ab558b0ac0c44c9f8f5b">DPU_AoAProcHWA_Cmd_MultiObjBeamFormingCfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03a0244a1c7e048283f4d3c2e69c90099ab">DPU_AoAProcHWA_Cmd_CompRxChannelBiasCfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03aa8173743c13e52505e938b0836320904">DPU_AoAProcHWA_Cmd_PrepareRangeAzimuthHeatMap</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ggadc90ce1d3b0754d35e654a90e75cbb03a0799dbe80bf53a9737fbb80bd3da8c51">DPU_AoAProcHWA_Cmd_ExtMaxVelocityCfg</a></li>
</ul>
<p class="startli">Full API details can be seen at <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l.html">aoaProc DPU External</a></p>
</li>
</ul>
<p><br />
<br />
<br />
 <a class="anchor" id="DSP-AOA-start"></a></p>
<h1><a class="anchor" id="section_DSP-AOA"></a>
DSP-AOA DPU (AoAProcDSP)</h1>
<h2><a class="anchor" id="section_AOADSP_Description"></a>
Description</h2>
<p>This DPU implements angle of arrival (AoA) estimation using the DSP only(HWA is not used). A high level data flow is illustrated in figure below.</p>
<div class="image">
<img src="dsp_aoa_top_level.png" alt="dsp_aoa_top_level.png"/>
<div class="caption">
DSP-AOA high level data flow</div></div>
<p> This DPU has the following restrictions regarding its input parameters:<br />
 The number of Doppler chirps (numDopplerChirps) must be a multiple of 4 and the number of Doppler bins (numDopplerBins) must be a power of 2 greater or equal than numDopplerChirps. Also, due to restrictions on the FFT implementation by DSPLIB, numDopplerBins must be at least 16.</p>
<table class="doxtable">
<tr>
<th align="left">Parameter </th><th align="left">Restriction  </th></tr>
<tr>
<td align="left">numDopplerChirps </td><td align="left">Must be a multiple of 4. </td></tr>
<tr>
<td align="left">numDopplerBins </td><td align="left">Must be at least 16. Must be a power of two, greater or equal than numDopplerChirps. </td></tr>
</table>
<p><br />
 Below are details of the DPU implementation.<br />
<br />
 The AoA DSP DPU processes data from the input CFAR detection list in a loop. For each object in the CFAR detection list the DPU performs the following operations:</p>
<p><b>Input data</b><br />
 The CFAR detection list determines which range bin should be processed for the given object. EDMA is used to move data from the radar cube into the DPU scratch buffers.<br />
 A ping/pong buffer scheme is used where in each iteration (ping/pong), data pertinent to one virtual antenna (for the given range bin) is brought from the radar cube matrix for processing.</p>
<p><b>Static Clutter Removal</b><br />
 When Static Clutter Removal is enabled, the mean value of the input samples to the Doppler FFT is subtracted from the samples.<br />
<br />
 <b>Windowing</b><br />
 Before the 2D FFT operation, input samples are multiplied by a real symmetric window function. Window size and coefficients are defined in <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga342643231501fcd8b02be43fd964e4b6">DPU_AoAProcDSP_HW_Resources</a>. Window coefficients must be provided by application. The same window used for the DSP Doppler DPU should be used here.<br />
 Note that the windowing function also executes IQ swap. Before windowing the samples are in the same format as in the radar cube, which is cmplx16ImRe_t. After windowing the output is in cmplx32ReIm_t format.<br />
<br />
 <b>2D FFT</b><br />
 2D FFT is computed, the output of the FFT has numDopplerBins samples of type cmplx32ReIm_t. The CFAR detection list determines which Doppler bin should be stored, the other bins are discarded.<br />
<br />
 <b>Repeat for all virtual antennas</b><br />
 The above steps are repeated for all virtual antennas for the given range bin before moving to the next step.<br />
<br />
 <b>Doppler Compensation</b><br />
 Doppler correction is done on the symbols belonging to TX1 and TX2 antennas.<br />
<br />
 <b>BPM decoding</b><br />
 If BPM is enabled, BPM is decoded. <br />
<br />
 <b>RX Channel Phase Compensation</b><br />
 RX channel phase compensation is performed. <br />
<br />
 <b>Angle of Arrival Estimation</b><br />
 Azimuth FFT is computed, Elevation FFT is computed. These FFTs are input to <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gabfd96f43cbd183ec53559694701517c9">AoAProcDSP_angleEstimationAzimElev</a>, which calculates the x/y/z coordinates of the object. <br />
<br />
 <b>Detailed block diagram for 3 TX 4 RX TDM-MIMO (no BPM)</b><br />
 The following figure depicts in detail the DPU implementation for the case of 3 TX and 4RX antennas (no BPM).</p>
<div class="image">
<img src="dsp_aoa_withMaxVelocity.png" alt="dsp_aoa_withMaxVelocity.png"/>
<div class="caption">
DSP-AOA detailed implementation for 3 TX 4 RX TDM-MIMO (no BPM)</div></div>
 <h2><a class="anchor" id="Azimuth_heat_mapDSP"></a>
Azimuth heatmap preparation</h2>
<p>In addition to AoA estimation, this DPU also generates data for computing azimuth heat-map (e.g for visualization purposes), this data is 2D FFT of the phase compensated Doppler bin 0 (static objects) output of each of the range bins.</p>
<p>Below are details of the Azimuth heatmap preparation.<br />
<br />
 <b>Input data</b><br />
 EDMA is used to move data from the radar cube into the DPU scratch buffers.<br />
 A ping/pong buffer scheme is used where in each iteration (ping/pong), data pertinent to one virtual antenna (for a given range bin) is brought from the radar cube matrix for processing.</p>
<p><b>Static Clutter Removal</b><br />
 When Static Clutter Removal is enabled, the mean value of the input samples to the Doppler FFT is subtracted from the samples.<br />
<br />
 <b>BPM decoding</b><br />
 If BPM is enabled, BPM is decoded. <br />
<br />
 <b>Doppler bin zero</b><br />
 Doppler bin zero is computed. Note that only bin zero is required.<br />
<br />
 <b>RX Channel Phase Compensation</b><br />
 RX channel phase compensation is performed. <br />
<br />
 <b>Repeat for all Azimuth virtual antennas for all range bins</b><br />
 The above steps are repeated for all Azimuth virtual antennas for all range bin. Note that data pertinent to the elevation virtual antennas are not processed.<br />
<br />
 The following figure depicts the heatmap computation for the case of 3TX and 4RX antennas.</p>
<div class="image">
<img src="dsp_aoa_azimuth.png" alt="dsp_aoa_azimuth.png"/>
<div class="caption">
DSP-AOA Azimuth heatmap computation</div></div>
 <h2><a class="anchor" id="aoa_bpmCfgNotes"></a>
BPM Scheme</h2>
<p>Similar to TDM-MIMO, in BPM scheme a frame consists of multiple blocks, each block consisting of 2 chirp intervals. However, unlike in TDM-MIMO where only one TX antenna active per chirp interval, two TX antennas are active in each chirp interval. This DPU only supports a BPM scheme with two TX antennas say A and B. In the even time slots (0, 2,...), both transmit antennas should be configured to transmit with positive phase i.e </p><pre class="fragment">(A,B) = (+,+) </pre><p> In the odd time slots (1, 3,...), the transmit antennas should be configured to transmit with phase<br />
 </p><pre class="fragment">(A,B) = (+,-) </pre><p> The BPM scheme is shown in the figure below where TX0 is used as antenna A and TX1 as antenna B.</p>
<div class="image">
<img src="bpm_antenna_cfg.png" alt="bpm_antenna_cfg.png"/>
<div class="caption">
BPM Scheme Antenna configuration</div></div>
<p> <b>BPM decoding</b><br />
 Let S1 and S2 represent chirp signals from two TX antennas. In time slot zero a combined signal Sa=S1+S2 is transmitted. Similarly in time slot one a combined signal Sb=S1-S2 is transmitted. Using the corresponding received signals, (S'a and S'b), at a specific received RX antenna, the components from the individual transmitters are separated out using<br />
</p><pre class="fragment">S'1=(S'a+S'b)/2 </pre><p> and </p><pre class="fragment">S'2=(S'a-S'b)/2 </pre><p> With simultaneous transmission on both TX antennas the total transmitted power per chirp interval is increased, and it can be shown that this translates to an SNR improvement of 3dB.<br />
</p>
<p><b>Order of the TX antennas in the BPM scheme</b><br />
 The BPM decoding will produce the virtual antenna array in the order (A, B), not (B, A), which will be used for AoA processing. Therefore, user must make sure that the (A, B) mapping to the physical transmit antennas corresponds to the intended virtual antenna order. For example, take the 6843 EVM antenna arrangement as shown in the figure below. Note that the DPU indexes the TX antennas as (TX0, TX1, TX2) which corresponds in the device to (TX1, TX2, TX3). <br />
 </p><div class="image">
<img src="coordinate_geometry.png" alt="coordinate_geometry.png"/>
<div class="caption">
6843 EVM antenna arrangement</div></div>
<p> Here two antennas TX1 and TX3 can create a virtual array of 8 antennas in the azimuth direction. In order to ensure correct virtual antenna processing for AoA calculations, after BPM decoding, the TX1 virtual antennas should precede the TX3 because the direction of spatial progression of RX antennas matches the direction of spatial progression of TX antennas when TX1 is before TX3 (post BPM decoding, the result should essentially be like TDM-MIMO). Therefore A=TX1 and B=TX3. In other words, BPM must be configured to do<br />
</p><pre class="fragment">(TX1,TX3) = (+,+) in even slots </pre><p> and<br />
</p><pre class="fragment">(TX1,TX3) = (+,-) in odd slots </pre><p> The opposite arrangement i.e<br />
</p><pre class="fragment">(TX3,TX1) = (+,+) in even slots </pre><p> and<br />
</p><pre class="fragment">(TX3,TX1) = (+,-) in odd slots </pre><p> will not work.<br />
<br />
 </p>
<h2><a class="anchor" id="aoa_bpmNotes"></a>
AoA DSP DPU changes when BPM is enabled</h2>
<p>When BPM is enabled the following changes are done in the AoA DSP DPU processing:<br />
 For AoA estimation, BPM decoding is done after Doppler compensation. The following figure depicts the DPU implementation when BPM is enabled.</p>
<div class="image">
<img src="dsp_aoa_BPM.png" alt="dsp_aoa_BPM.png"/>
<div class="caption">
BPM Scheme Antenna configuration</div></div>
<h1><a class="anchor" id="api_sectionDSP"></a>
AoAProcDSP APIs</h1>
<ul>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0a2998a05d3f4265986602cda6f3891b">DPU_AoAProcDSP_init</a> - DPUs initialization function.</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga15c71f6d1205d3d4e64741559524d6fc">DPU_AoAProcDSP_config</a> - DPUs configuration function. The configuration can only be done after the DPU has been initialized using <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0a2998a05d3f4265986602cda6f3891b">DPU_AoAProcDSP_init</a>.</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga47ef8666bb718de320d120dc5c2bdc59">DPU_AoAProcDSP_process</a> - DPUs processing function performs AoA estimation of detected objects in the given frame. This processing can only be done after the DPU has been configured.</li>
<li><p class="startli"><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga60106cdb5452c5ac9afac003c7b62d8a">DPU_AoAProcDSP_control</a> - DPUs control function. It processes following messages from DPC:</p><ul>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gga396ce2415ce46bb73f6ce2266a498512a8697070672b980a4b22310933aaac5bc">DPU_AoAProcDSP_Cmd_FovAoACfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gga396ce2415ce46bb73f6ce2266a498512a8c61479caa0ffde828daf011d469189d">DPU_AoAProcDSP_Cmd_MultiObjBeamFormingCfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gga396ce2415ce46bb73f6ce2266a498512a34aa82a04627a188f82bfdfb97b8f0cb">DPU_AoAProcDSP_Cmd_CompRxChannelBiasCfg</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gga396ce2415ce46bb73f6ce2266a498512ae3f552c65a8be2063fac6ca4a5187d01">DPU_AoAProcDSP_Cmd_PrepareRangeAzimuthHeatMap</a>,</li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gga396ce2415ce46bb73f6ce2266a498512a4eaef9d4d0cce668f4a616478bd1956a">DPU_AoAProcDSP_Cmd_staticClutterCfg</a></li>
<li><a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gga396ce2415ce46bb73f6ce2266a498512a47e8cc30be211469980f91e61e11be4b">DPU_AoAProcDSP_Cmd_ExtMaxVelocityCfg</a></li>
</ul>
<p class="startli">Full API details can be seen at <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___e_x_t_e_r_n_a_l.html">aoaProc DPU External</a> <br />
<br />
<br />
</p>
</li>
</ul>
<p><a class="anchor" id="HWA-DSP-Common-start"></a></p>
<h1><a class="anchor" id="common_HWA_DSP_DPUs"></a>
Common Sections for AoAProcDSP and AoAProcHW</h1>
<p>The following sections are common for AoAProcDSP and AoAProcHWA<br />
 </p>
<h2><a class="anchor" id="Sect_dopplerComp"></a>
Doppler Compensation</h2>
<p>Doppler compensation function (<a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gaa67bba66efe93265f6d19bbd9605d1e8">aoaHwa_dopplerCompensation</a> or <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga87803ae8a5426939343a2b43240c2120">AoAProcDSP_dopplerCompensation</a>) is done by CPU after Rx channel phase/gain compensation. It performs compensation for the Doppler phase shift on the symbols corresponding to the virtual Rx antennas. In case of 2Tx MIMO scheme, the second set of Rx symbols is rotated by half of the estimated Doppler phase shift between subsequent chirps corresponding to the same Tx antenna. In case of 3Tx MIMO elevation scheme, the second set of Rx symbols is rotated by 1/3 of the estimated Doppler phase shift, while the third set of Rx symbols is rotated by 2/3 of the estimated Doppler phase shift. Refer to the pictures below. <a class="anchor" id="Figure_doppler"></a> </p><div class="image">
<img src="angle_doppler_compensation.png" alt="angle_doppler_compensation.png"/>
<div class="caption">
Figure_doppler: Doppler Compensation</div></div>
 <h2><a class="anchor" id="Extended_max_velocity"></a>
Extended maximum velocity feature</h2>
<p>In TDM-MIMO scheme the angle resolution increases with the number of Tx antennas, as the length of array of Rx virtual antennas increases, however the maximum unambiguous radial velocity Vmax decreases proportionally to the number of Tx antennas, as illustrated in Figure below.</p>
<div class="image">
<img src="max_velocity_comparison.png" alt="max_velocity_comparison.png"/>
<div class="caption">
Maximum unambiguous velocities in TDM-MIMO for different number of Tx antennas, assuming the same profile configuration in each scheme</div></div>
<p> For the target velocities beyond Vmax, the Doppler measurements are aliased. This is illustrated in Figure below for 3TxTDM-MIMO where several actual velocities can fold into the same aliased velocity.</p>
<div class="image">
<img src="max_velocity_aliasing.png" alt="max_velocity_aliasing.png"/>
<div class="caption">
Examples of different actual velocities beyond Vmax folding into same aliased velocity</div></div>
<p> Maximum velocity extension method is based on the maximum peak in angular FFTs. It consists of the following steps:</p>
<ol type="1">
<li>Calculate phase change <img class="formulaInl" alt="$\Delta\varphi_{dop}=2\pi\frac{l_d}{N_{DopFFT}}$" src="form_2.png"/> where <img class="formulaInl" alt="$l_d$" src="form_3.png"/> is the Doppler detection index.</li>
<li>Test <img class="formulaInl" alt="$N_{Tx}$" src="form_4.png"/> hypotheses <img class="formulaInl" alt="$H_n$" src="form_5.png"/>, <img class="formulaInl" alt="$ n=0,...N_{Tx}-1$" src="form_6.png"/>. For each hypothesis calculate phase change <img class="formulaInl" alt="$\Delta\varphi_n$" src="form_7.png"/>.<ul>
<li>for even <img class="formulaInl" alt="$N_{Tx}$" src="form_4.png"/> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Delta\varphi_n= \left\{ \begin{array}{lr} \Delta\varphi_{dop}+2\pi(n-\frac{N_{Tx}}{2}) &amp; : \Delta\varphi_{dop} \ge 0\\ \Delta\varphi_{dop}+2\pi(n-\frac{N_{Tx}}{2}+1) &amp; : \Delta\varphi_{dop} &lt; 0 \end{array}\right. \]" src="form_8.png"/>
</p>
</li>
<li>for odd <img class="formulaInl" alt="$N_{Tx}$" src="form_4.png"/> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Delta\varphi_n= \Delta\varphi_{dop}+2\pi(n- \lfloor\frac{N_{Tx}}{2}\rfloor) \]" src="form_9.png"/>
</p>
 Figure below illustrates in 3Tx TDM-MIMO 3 hypothetical phase changes <img class="formulaInl" alt="$\Delta\varphi_n$" src="form_7.png"/> based on measured <img class="formulaInl" alt="$\Delta\varphi_{dop}$" src="form_10.png"/>. <div class="image">
<img src="max_velocity_unwrpped_phases.png" alt="max_velocity_unwrpped_phases.png"/>
<div class="caption">
Doppler phase offsets under different Hypothesis based on measured phase offset</div></div>
</li>
</ul>
</li>
<li>Apply Doppler correction on the <img class="formulaInl" alt="$i^{th}$" src="form_11.png"/> set of virtual Rx antennas: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Delta\varphi_i= i \cdot \frac{\Delta\varphi_n}{N_{Tx}}, \;\; i=0,1,...,N_{Tx} - 1 \]" src="form_12.png"/>
</p>
</li>
<li>Compute azimuth spectrum <img class="formulaInl" alt="$S_n$" src="form_13.png"/> for each <img class="formulaInl" alt="$H_n$" src="form_5.png"/> and find the peaks <img class="formulaInl" alt="$P_n = max(Sn)$" src="form_14.png"/>.</li>
<li>Find m = argmax <img class="formulaInl" alt="$P_n$" src="form_15.png"/>,</li>
<li>Complete the azimuth estimation using the data from <img class="formulaInl" alt="$S_m$" src="form_16.png"/></li>
</ol>
<p>Extended maximum velocity feature can be enabled/disabled by using the cli command: extendedMaxVelocity. When the feature is enabled, local core performs Doppler compensation for all possible hypotheses, 2 hypotheses for 2Tx, and 3 hypotheses for 3Tx antenna TDM MIMO scheme. HWA calculates FFTs for all hypotheses, and in the local core one hypothesis is picked based on the maximum peak in the magnitude square outputs.</p>
<h3><a class="anchor" id="LimitationExtMaxVel"></a>
Limitation of extended maximum velocity algorithm</h3>
<p>The algorithm works well when the single target occurs in range/Doppler bin. However it can fail with multiple targets in the same range/Doppler bin. It also fails with multiple targets at the same range and different velocities wrapped to the same Doppler bin.</p>
<h2><a class="anchor" id="dataXYZ"></a>
Data Path - Direction of Arrival Estimation (x,y,z)</h2>
<p>This processing is done on CPU in the function <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga1a8c016cc5a74e6bc61558bcceac9fea">AoAProcHWA_angleEstimationAzimElev</a> or <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gabfd96f43cbd183ec53559694701517c9">AoAProcDSP_angleEstimationAzimElev</a>. The actual computation per detected object is performed by <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gac3b1494128cc03dd65c5b3d2d7035e38">AoAProcHWA_XYZestimation</a> or <a class="el" href="group___d_p_u___a_o_a_p_r_o_c___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gae69bb56cd7b8237663e99a4c44bd9647">AoAProcDSP_XYZestimation</a>. <a class="anchor" id="Figure_geometry"></a> </p><div class="image">
<img src="coordinate_geometry.png" alt="coordinate_geometry.png"/>
<div class="caption">
Figure A: Coordinate Geometry</div></div>
<p> <br />
<a class="anchor" id="Figure_wz"></a> </p><div class="image">
<img src="coordinate_geometry_wz.png" alt="coordinate_geometry_wz.png"/>
<div class="caption">
Figure wz</div></div>
<p> <br />
<a class="anchor" id="Figures_wx"></a> </p><div class="image">
<img src="coordinate_geometry_wx.png" alt="coordinate_geometry_wx.png"/>
<div class="caption">
Figures wx</div></div>
<p> <a class="el" href="index.html#Figure_geometry">Figure_geometry</a> shows orientation of x,y,z axes with respect to the sensor/antenna positions. The objective is to estimate the (x,y,z) coordinates of each detected object. <img class="formulaInl" alt="$w_x$" src="form_17.png"/> is the phase difference between consecutive receive azimuth antennas of the 2D FFT and <img class="formulaInl" alt="$w_z$" src="form_18.png"/> is the phase difference between azimuth and corresponding elevation antenna above the azimuth antenna. The phases for each antenna are shown in the <a class="el" href="index.html#Figure_doppler">Figure_doppler</a>. <a class="el" href="index.html#Figure_wz">Figure_wz</a> shows that the distance AB which represents the relative distance between wavefronts intersecting consecutive elevation antennas is <img class="formulaInl" alt="$AB = \frac{\lambda}{2} \sin (\phi)$" src="form_19.png"/>. Therefore <img class="formulaInl" alt="$W_z = \frac{2\pi}{\lambda} \cdot AB$" src="form_20.png"/>, therefore <img class="formulaInl" alt="$W_z = \pi \sin (\phi)$" src="form_21.png"/>. Note that the phase of the lower antenna is advanced compared to the upper antenna which is why picture X shows -Wz term in the upper antenna. <a class="el" href="index.html#Figures_wx">Figures_wx</a> show that distance CD which represents the relative distance between wavefronts intersecting consecutive azimuth antennas is <img class="formulaInl" alt="$CD = \frac{\lambda}{2} \sin (\theta) \cos (\phi)$" src="form_22.png"/> Therefore <img class="formulaInl" alt="$w_x = \frac{2\pi}{\lambda} \cdot CD$" src="form_23.png"/>, therefore <img class="formulaInl" alt="$w_x = \pi \sin (\theta) \cos (\phi)$" src="form_24.png"/>. For a single obstacle, the signal at the 8 azimuth antennas will be ( <img class="formulaInl" alt="$A_1$" src="form_25.png"/> and <img class="formulaInl" alt="$\psi$" src="form_26.png"/> are the arbitrary starting amplitude/phase at the first antenna): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_1 e^{j\psi} [ 1 \; e^{jw_x} \; e^{j2w_x} \; e^{j3w_x} \; e^{j4w_x} \; e^{j5w_x} \; e^{j6w_x} \; e^{j7w_x} ] \]" src="form_27.png"/>
</p>
<p>An FFT of the above signal will yield a peak <img class="formulaInl" alt="$P_1$" src="form_28.png"/> at <img class="formulaInl" alt="$w_x$" src="form_17.png"/>, with the phase of this peak being <img class="formulaInl" alt="$\psi$" src="form_26.png"/> i.e </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_1 = A_1 e^{j\psi} \]" src="form_29.png"/>
</p>
<p> If <img class="formulaInl" alt="$k_{MAX}$" src="form_30.png"/> is the index of the peak in log magnitude FFT represented as signed index in range <img class="formulaInl" alt="$[-\frac{N}{2}, \frac{N}{2}-1]$" src="form_31.png"/>, then <img class="formulaInl" alt="$ w_x $" src="form_32.png"/> will be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_x = \frac{2\pi}{N}k_{MAX} \]" src="form_33.png"/>
</p>
<p>The signal at the 4 elevation antennas will be: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_2 e^{j(\psi + 2 w_x - w_z)} [ 1 \; e^{jw_x} \; e^{j2w_x} \; e^{j3w_x}] \]" src="form_34.png"/>
</p>
<p>An FFT of the above signal will yield a peak <img class="formulaInl" alt="$P_2$" src="form_35.png"/> at <img class="formulaInl" alt="$w_x$" src="form_17.png"/>, with the phase of this peak being <img class="formulaInl" alt="$\psi + 2w_x - w_z$" src="form_36.png"/>. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_2 = A_2 e^{j(\psi+ 2 w_x - w_z)} \]" src="form_37.png"/>
</p>
<p>From above, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_1 \cdot P_2^* = A_1 \cdot A_2 e^{j(\psi - (\psi+ 2 w_x - w_z))} \]" src="form_38.png"/>
</p>
<p>Therefore, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ w_z=\angle (P_1 \cdot P_2^* \cdot e^{j2w_x}) \]" src="form_39.png"/>
</p>
<pre class="fragment">Calculate range (in meters) as:
</pre> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ R=k_r\frac{c \cdot F_{SAMP}}{2 \cdot S \cdot N_{FFT}} \]" src="form_40.png"/>
</p>
<p> where, <img class="formulaInl" alt="$c$" src="form_41.png"/> is the speed of light (m/sec), <img class="formulaInl" alt="$k_r$" src="form_42.png"/> is range index, <img class="formulaInl" alt="$F_{SAMP}$" src="form_43.png"/> is the sampling frequency (Hz), <img class="formulaInl" alt="$S$" src="form_44.png"/> is chirp slope (Hz/sec), <img class="formulaInl" alt="$N_{FFT}$" src="form_45.png"/> is 1D FFT size. Based on above calculations of <img class="formulaInl" alt="$R$" src="form_46.png"/>, <img class="formulaInl" alt="$w_x$" src="form_17.png"/> and <img class="formulaInl" alt="$w_z$" src="form_18.png"/>, the <img class="formulaInl" alt="$(x,y,z)$" src="form_47.png"/> position of the object can be calculated as seen in the <a class="el" href="index.html#Figure_geometry">Figure_geometry</a>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = R\cos(\phi)\sin(\theta) = R\frac{w_x}{\pi}, \;\;\;\;\; z = R\sin(\phi) = R\frac{w_z}{\pi},\;\;\;\;\; y = \sqrt{R^2-x^2-z^2} \]" src="form_48.png"/>
</p>
<p> The computed <img class="formulaInl" alt="$(x,y,z)$" src="form_47.png"/> along with the Doppler value for each detected object are populated in the output list, structured as <a class="el" href="struct_d_p_i_f___point_cloud_cartesian__t.html">DPIF_PointCloudCartesian_t</a>.</p>
<p>If the multi object beam forming feature is enabled, (it can be dynamically controlled from CLI), the algorithm searches for the second peak in the azimuth FFT output and compares its height relative to the first peak height, and if detected, it creates new object in the output list with the same Doppler value and calculated (x,y,z) coordinates.</p>
<h2><a class="anchor" id="fovSubSection"></a>
Elimination of detected objects based on FoV limits</h2>
<p>The AoA DPU filters out detected objects whose azimuth, <img class="formulaInl" alt="$\theta$" src="form_49.png"/>, and elevation, <img class="formulaInl" alt="$\phi$" src="form_50.png"/>, angles are not within configured FoV limits. The DPU receives the following FoV parameters:</p>
<p><img class="formulaInl" alt="$\phi_{min},\;\phi_{max},$" src="form_51.png"/> - elevation angle FoV limits</p>
<p><img class="formulaInl" alt="$\theta_{min},\;\theta_{max}$" src="form_52.png"/> - azimuth angle FoV limits</p>
<p>The DPU computes <img class="formulaInl" alt="$W_z$" src="form_53.png"/> and <img class="formulaInl" alt="$W_x$" src="form_54.png"/> directly from azimuth FFT output data, where</p>
<p><img class="formulaInl" alt="$W_z = w_z/\pi$" src="form_55.png"/></p>
<p><img class="formulaInl" alt="$W_x = w_x/\pi$" src="form_56.png"/></p>
<p>From equations in previous section the following holds</p>
<p><img class="formulaInl" alt="$W_z = \sin(\phi)$" src="form_57.png"/></p>
<p><img class="formulaInl" alt="$W_x = \cos(\phi) \sin(\theta)$" src="form_58.png"/></p>
<p>Because sine is a monotonic increasing function in the maximum possible range of -90 deg, 90 deg, the elevation angle <img class="formulaInl" alt="$\phi$" src="form_50.png"/> FoV limits can be checked on <img class="formulaInl" alt="$W_z$" src="form_53.png"/> as follows</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sin(\phi_{min}) \leq W_z \leq \sin(\phi_{max}) \]" src="form_59.png"/>
</p>
<p>Since <img class="formulaInl" alt="$W_x$" src="form_54.png"/> is not monotonic in <img class="formulaInl" alt="$\phi$" src="form_50.png"/> but monotonic on <img class="formulaInl" alt="$\theta$" src="form_49.png"/>, the azimuth angle <img class="formulaInl" alt="$\theta$" src="form_49.png"/> limits can be checked by checking <img class="formulaInl" alt="$W_x$" src="form_54.png"/> after computing the <img class="formulaInl" alt="$\cos(\phi)$" src="form_60.png"/> on the measured <img class="formulaInl" alt="$\phi$" src="form_50.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \cos(\phi)\sin(\theta_{min}) \leq W_x \leq \cos(\phi) \sin(\theta_{max}) \]" src="form_61.png"/>
</p>
<p>where <img class="formulaInl" alt="$\cos(\phi) = \sqrt{1 - \sin(\phi)^2} = \sqrt{1 - W_z^2}$" src="form_62.png"/>. Note that the terms <img class="formulaInl" alt="$\sin(\phi_{min})$" src="form_63.png"/>, <img class="formulaInl" alt="$\sin(\phi_{max})$" src="form_64.png"/>, <img class="formulaInl" alt="$\sin(\theta_{min})$" src="form_65.png"/> and <img class="formulaInl" alt="$\sin(\theta_{max})$" src="form_66.png"/> are precomputed during configuration time and stored in the dpu's instance (<a class="el" href="struct_d_p_u___ao_a_proc__fov_aoa_local_cfg__t.html">DPU_AoAProc_fovAoaLocalCfg_t</a>) to be used in the real-time limit checks above. The brute-force method of checking limits on <img class="formulaInl" alt="$\phi$" src="form_50.png"/> and <img class="formulaInl" alt="$\theta$" src="form_49.png"/> directly requires computing these, which involves two sin inverses, one cosine and one division which are computationally more expensive than the above method. </p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
