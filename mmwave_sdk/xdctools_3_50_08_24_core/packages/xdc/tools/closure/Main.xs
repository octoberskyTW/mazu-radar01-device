/* 
 * Copyright (c) 2008 Texas Instruments and others.
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *      Texas Instruments - initial implementation
 *
 * */

/*
 *  ======== Main.xs ========
 */

/* verbose flag */
var vfl = false;

/*
 *  ======== run ========
 */
function run(cmdr, args)
{
    if (args.length < 1) {
        cmdr.usage("Error: package base directory must be supplied");
        return (0);
    }
    else if (args.length > 1) {
        cmdr.usage("Warning: only one argument is needed, all additional"
            + " arguments are ignored");
    }

    /* pkgDir is the name of the config directory passed on the command line */
    var pkgDir = new java.io.File(args[0]);
    if (!pkgDir.exists()) {
        print("Error: The directory " + args[0] + " cannot be found!");
        return (1);
    }
    if (!pkgDir.isDirectory()) {
        print("Error: The file " + args[0] + " is not a directory!");
        return (2);
    }

    if (this.verboseFlag) {
        vfl = true;
    }

    if (this.aggFilter && this.filter == 3) {
        this.filter = 5;
    }

    var configPkgPath = _unixJSPath(pkgDir.getCanonicalPath());

    var bldxml = _openXML(configPkgPath + "/package/package.bld.xml");
    if (bldxml == null || bldxml.executables == null
        || bldxml.executables.executable == null
        || bldxml.executables.executable[0] == null) {
        print("Error: The directory " + configPkgPath + " does not contain "
            + "a program configuration!");
        return (3);
    }

    var program = bldxml.executables.executable[0].@pname + "";
    var cfgNameBase = bldxml.executables.executable[0].@xCfgPrefix + "";
    var programProfile = bldxml.executables.executable[0].@profile + "";
    var trd = bldxml.targets.target[0].@rootDir + "";
    var targetName = bldxml.targets.target[0].@name + "";
    var targetRootDir = null;
    if (trd != "") {
        targetRootDir = java.io.File(trd).getCanonicalPath() + "";
    }
    if (vfl) {
        print("Reading " + configPkgPath + "/package/package.bld.xml");
        print("Executable: " + program);
        print("Profile: " + programProfile);
        print("Target: " + targetName);
        print("Compiler: " + targetRootDir);
    }

    var cfgxml = _openXML(configPkgPath + "/" + cfgNameBase + ".cfg.xml");
    if (cfgxml == null) {
        print("Error: The configuration for the executable " + program
            + " cannot be found!");
        return (4);
    }

    /* configPkgName could be also extracted from the 'pkgDir' parameter
     * passed on the command line, but since we are already opening cfg.xml,
     * we get it form there because we know the exact format of @name.
     */
    var configPkgName = cfgxml.@name.substr(0, cfgxml.@name.indexOf("/"));
    if (vfl) {
        print("Reading " + configPkgPath + "/" + cfgNameBase + ".cfg.xml");
    }

    /* For each package, we keep its name as a key in the 'pkgs' hash and 
     * its base directory as the key's value. 
     */
    var pkgs = {};
    var uniqReps = {};

    /* exeDir is the directory above configPkg, where the application is
     * located.
     */
    var exeDir = "";
    /* srcDir is an optional directory which contains sources and libraries
     * generated by some products during the configuration. The directory is
     * specified in xdc.cfg.SourceDir.outputDir.
     */
    var srcDir = "";
    for each (item in cfgxml.imports["package"]) {
        var pname = item.@name + "";
        var pbase = _unixJSPath(item.@repository);

        pkgs[pname] = pbase;
        uniqReps[pbase] = 1;

        if (configPkgName == item.@name) {
            exeDir = _unixJSPath(item.@repository);
        }
        /* While we are going through packages, we can grab the directory
         * where products might add source files and create libraries out of
         * them.
         */
        if (item.@name == "xdc.cfg") {
            var srcMod = item.module.(@name == "xdc.cfg.SourceDir");
            srcDir = srcMod.*.(@name == "outputDir").@value + "";
            if (srcDir != "") {
                srcDir
                    = _unixJSPath(java.net.URLDecoder.decode(srcDir, "UTF-8"));

                var srcDirFile = java.io.File(srcDir);
                if (!srcDirFile.isAbsolute()) {
                    srcDirFile = java.io.File(configPkgPath + "/" + srcDir)
                                 .getCanonicalFile();
                }
                srcDir = _unixJSPath(srcDirFile.getCanonicalPath());
            }
            /* getting rid of slashes at the end */
            srcDir = srcDir.replace(/\/+$/, "");
        }
    }

    /* add packages specified on the command line */
    var pathTool = xdc.module("xdc.tools.path.Main");
    for each (var p in this.includes) {
        if (pkgs[p] != null) {
            continue; /* skip packages already added */
        }

        var packageFound = false;
        var repString = "";
        for (var rep in uniqReps) {
            repString += rep + ";";

            var res = pathTool.exec(
                ["-a", "-P", rep + p.replace(/\./g, '/')]);
            if (res.length != 0) {
                pkgs[p] = rep.replace(/\\/g, "/");
                packageFound = true;
                break;
            }
        }
        if (!packageFound) {
            // replace last ';' with '.'
            repString = repString.substring(0, repString.length - 1) + ".";
            print("Warning: Cannot find the included package '" + p
                + "' along the path: " + repString);
            continue;
        }
    }

    /* The default location for the bundle is alongside configPkg, in the same
     * directory where the application is originally built.
     */
    var newRep = java.io.File(program.replace(/\./, "_") + "_rep");
    if (this.destination != "") {
        newRep = java.io.File(this.destination);
    }
    var newRepName = newRep.toString() + "";

    if (newRep.exists()) {
        if (!newRep.isDirectory()) {
            print("Error: File " + newRepName + " already exists!");
            return(5);
        }
        else if (!newRep["delete"]()) {
            print("Error: The repository " + newRepName + " already exists,"
                + " and it is not empty!");
            return(6);
        }
        else {
            newRep.mkdirs();
        }
    }
    else {
        newRep.mkdirs();
    }

    newRepName = _unixJSPath(newRep.getCanonicalPath());
    if (vfl) {
        print("Bundle repository: " + newRepName);
    }

    var nl = "";

    if (!vfl) {
        java.lang.System.out.print("Copying ");
        nl = "\n";
    }

    var repoman = xdc.module("xdc.tools.repoman.Main");
    for (var pname in pkgs) {
        if (vfl) {
            print("Copying '" + pname + "' from " + pkgs[pname] + " to "
                + newRepName);
        }
        else {
            java.lang.System.out.print(".");
        }

        var remoteRep = new java.io.File(pkgs[pname]);
        if (remoteRep.exists()) {
            if (newRepName == remoteRep.getCanonicalPath() + "") {
                print(nl + "Warning: The package '" + pname + "' is "
                    + "already in " + newRepName);
            }
            else {
                repoman.exec(["-c", "-r" + newRepName, "-p", pkgs[pname],
                    pname]);
            }
        }
        else {
            print(nl + "Error: Repository " + pkgs[pname] 
                  + " cannot be found!");
            return(7);
        }
    }

    if (srcDir != "") {
        /* We have to get the name of the last component of srcDir and add it
         * to newRep because otherwise deepCopyFiles will take content from
         * srcDir and copy it to newRep, but it won't create a separate
         * directory.
         */
        var lastComp = srcDir.replace(
            _unixJSPath(srcDirFile.getParentFile().getCanonicalPath()), "");
        if (vfl) {
            print("Copying '" + srcDir + "' to '" + newRepName);
        }
        Packages.xdc.services.global.Host.deepCopyFiles(srcDirFile,
            java.io.File(newRepName + "/" + lastComp));
    }
    print();

    var compOptFile = configPkgPath + "/compiler.opt";
    if (_replaceComp(compOptFile, newRepName + "/compiler.opt", exeDir)
        == false) {
        print("Error: The file " + compOptFile + " cannot be found!");
        return(8);
    }

    var compOptDefsFile = configPkgPath + "/compiler.opt.defs";
    if (_replaceComp(compOptDefsFile, newRepName + "/compiler.opt.defs", exeDir)
        == false) {
        print("Error: The file " + compOptDefsFile + " cannot be found!");
        return(9);
    }

    var linkCmdFile = configPkgPath + "/linker.cmd";

    /* We keep the list of libraries found in the linker command files to
     * use them as a filter for removing unnecessary libraries.
     */
    var libs = _replaceLink(linkCmdFile, newRepName + "/linker.cmd", uniqReps,
        exeDir, srcDir, targetName);

    if (libs.length == 0) {
        /* no required libraries in the bundle */
    }
    else if (libs == false) {
        print("Error: The file " + linkCmdFile + " cannot be found!");
        return(10);
    }

    if (targetName.search("ti.targets") == 0
        && programProfile.search("whole_program") == 0) {
        if (vfl) {
            print("Special case: TI target and the whole_program profile");
        }
        var xdlFile = configPkgPath + "/" + cfgNameBase + "_x.xdl";
        var newXdlFile = newRepName + "/" + configPkgName + "/" + cfgNameBase
            + "_x.xdl";
        /* The generated xdl file does not contain any object files or linker
         * scripts from the config package.
         */
        var xlibs = _replaceLink(xdlFile, newXdlFile, uniqReps, "", srcDir,
            targetName);
        if (xlibs == false) {
            print("Error: The file " + xdlFile + " cannot be found!");
            return(11);
        }
        libs = libs.concat(xlibs);
    }

    libs.sort();
    var libsSave = [];
    libsSave = libsSave.concat(libs);
    if (vfl) {
        print("Required libraries");
    }
    for (var i = 0; i < libs.length; i++) {
        if (vfl) {
            print(i + ". " + libs[i]);
        }
    }

    /*
     * The file rov.xs is copied next to the .out file and used for ROV, unless
     * the user asked to remove it.
     */
    if (this.filter < 6) {
        var rovxsOld = configPkgPath + "/" + cfgNameBase + ".rov.xs";
        var index = rovxsOld.lastIndexOf("/");
        var rovxsNew = rovxsOld.substr(index);
        rovxsNew = newRepName + rovxsNew;
        _copy(rovxsOld, rovxsNew);
    }

    /* Filtering out files */
    if (this.filter >= 3 && !vfl) {
        java.lang.System.out.print("Filtering libraries ");
    }

    /* This loop removes the libraries that are not being referenced by the
     * linker command files. This is not aggressive filtering, the aggressive
     * filtering is removing everything except referenced libraries.
     */
    for (var pname in pkgs) {
        var newBaseDir = newRepName + "/" + pname.replace(/\./g, "/");
        var f = newBaseDir + "/package/package.bld.xml";

        if (vfl) {
            print("Filtering libraries from " + newBaseDir);
        }
        else if (this.filter >= 3 && !vfl) {
            java.lang.System.out.print(".");
        }

        var pkgXml = _openXML(f);
        if (pkgXml == null) {
            if (vfl) {
                print("Cannot find " + f);
            }
            continue;
        }
        for each (item in pkgXml.libraries["library"]) {
            var libRelName = pname.replace(/\./g, "/") + "/" + item.@pname;
            var libFullName = newRepName + "/" + libRelName;
            /* Find (efficiently!?) if libRelName shows up in libs, otherwise
             * find its java.io.File representation and remove it.
             */
            if (libs.length == 0) {
                if (vfl) {
                    print("    Deleting " + libRelName);
                }
                if (this.filter >= 3) {
                    java.io.File(libFullName)["delete"]();
                }
                if (this.filter >= 1) {
                    java.io.File(libFullName + ".mak")["delete"]();
                }
            }

            for (var j = 0; j < libs.length; j++) {
                if (libs[j] == libRelName) {
                    libs.splice(j, 1);
                    if (this.filter >= 1) {
                        java.io.File(libFullName + ".mak")["delete"]();
                    }
                    break;
                }
                /* We passed the point where 'libRelName' would be if it were
                 * in the list of the required libraries, or we reached the
                 * last required library, and haven't found 'libRelName'
                 * among them.
                 */
                else if (libs[j] > libRelName || j == libs.length - 1) {
                    if (vfl) {
                        print("    Deleting " + libRelName);
                    }
                    if (this.filter >= 3) {
                        java.io.File(libFullName)["delete"]();
                    }
                    if (this.filter >= 1) {
                        java.io.File(libFullName + ".mak")["delete"]();
                    }
                    break;
                }
            }
        }
    }

    libs = libsSave;
    for (var i = 0; i < libs.length; i++) {
        if (vfl) {
            print(i + ". " + libs[i]);
        }
    }

    for (var pname in pkgs) {
        var newBaseDir = newRepName + "/" + pname.replace(/\./g, "/");
        var pkgLibDir = java.io.File(newBaseDir + "/package/lib");
        /* The object files in /package/lib directory are not needed anymore,
         * so we remove them if filtering is >= 1.
         */
        if (this.filter >= 1 && pkgLibDir.exists()) {
            _deleteDir(pkgLibDir);
        }
        /* This is the only place where we use this.aggFilter. */
        _deleteMisc(java.io.File(newBaseDir), this.filter, newRepName, libs);
    }

    if (srcDir != "") {
        _deleteMisc(java.io.File(newRepName + "/" + lastComp),
                    this.filter, newRepName, libs);
    }

    print();
    return (0);
}

/*
 *  ======== _deleteDir ========
 */
function _deleteDir(dir) {
    var files = dir.list();
    for (var i = 0; i < files.length; i++) {
        var f = java.io.File(dir, files[i]);
        if (f.isDirectory()) {
            _deleteDir(f);
        }
        else {
            f["delete"]();
        }
    }
    dir["delete"]();
}

/*
 *  ======== _deleteMisc ========
 *  @param(dir)         directory whose content is filtered
 *  @param(fil)         level of filtering
 *  @param(base)        repository path; used to determine the file path
 *                      relative to the repository
 *  @param(libs)        array of required libraries
 */
function _deleteMisc(dir, fil, base, libs) {
    if (fil == 0) {
        return;
    }
    else if (vfl) {
        print("Filtering " + dir.toString());
    }
    var files = dir.list();
    Packages.java.util.Arrays.sort(files);
    for (var i = 0; i < files.length; i++) {
        var f = java.io.File(dir, files[i]);
        if (f.isDirectory()) {
            _deleteMisc(f, fil, base, libs);
        }
        else if (fil >= 1
            && (files[i].match(/.*(\.java|\.class|\.jar|\.xml|\.ccs|\.sch)$/)
            || files[i].match(/.*(\.pdf|\.c|\.cpp|\.opt|\.pobj|\.html)$/))) {
            f["delete"]();
        }
        else if (fil >= 5) {
            if (!files[i].match(/.*\.h$/)) {
                var neededLib = false;
                var relFile = _unixJSPath(f.toString());
                relFile = relFile.replace(base + "/", "");
                for (var j = 0; j < libs.length; j++) {
                    if (libs[j] == relFile) {
                        neededLib = true;
                        break;
                    }
                }
                if (!neededLib) {
                    f["delete"]();
                }
            }
        }
    }
}

/*
 *  ======== _replaceComp ========
 *  @param(of)          name of the original file
 *  @param(nf)          new copy of the file
 *  @param(exePath)     path to the directory containing the config package, 
 *                      we need to remove that string from all references to
 *                      end up with only relative paths starting with the
 *                      name of the config package.
 */
function _replaceComp(of, nf, exePath)
{

    if (vfl) {
        print(of + " processed and copied to " + nf);
    }
    var File = xdc.module('xdc.services.io.File');
    var oldFile = File.open(of, "r");
    if (oldFile == null) {
        return (false);
    }
    var newFile = File.open(nf, "w");
    var line;
    while ((line = oldFile.readLine()) != null) {
        var newLine = line;

        /* Replace the absolute path to the config directory with only the
         * name of the config directory.
         */
        if (exePath != "") {
            var regexp = new RegExp(exePath, "gi");
            newLine = newLine.replace(regexp, "");

            var exePathInv = exePath.replace(/\//g, "\\\\");
            regexp = new RegExp(exePathInv, "gi");
            newLine = newLine.replace(regexp, "");
        }

        /* We are removing all -I options because all copied header files will
         * be rooted in the top directory of the new bundle directory, so
         * the user only has to specify -I<bundle_dir> in his makefile. At
         * this time we don't even know that <bundle_dir> because the whole
         * bundle can be moved to any new directory or even a new host.
         */
        newLine = newLine.replace(/-I"[^"]*"/g, "");
        newLine = newLine.replace(/-I\S+/g, "");

        newFile.writeLine(newLine);
    }
    newFile.close();
    oldFile.close();

    return (true);
}

/*
 *  ======== _replaceLink ========
 *  @param(of)          name of the original file
 *  @param(nf)          new copy of the file
 *  @param(reps)        list of all repositories
 *  @param(exePath)     path to the directory containing the config package, we
 *                      need to remove that string from all references to
 *                      end up with only relative paths starting with the
 *                      name of the config package. The config package is 
 *                      always in 'reps, but we keep it separate so we can
 *                      replace it first, in case one of the repositories
 *                      matches some substring from exePath.
 *  @param(srcDir)      path to the directory containing libraries generated
 *                      by some products. These libraries are also copied to 
 *                      the bundle and referenced by relative paths starting
 *                      with SourceDir.outputDir.
 *  @param(tname)       target name
 */
function _replaceLink(of, nf, reps, exePath, srcDir, tname)
{
    var counter = 0;
    var lib = [];
    var File = xdc.module('xdc.services.io.File');
    var oldFile = File.open(of, "r");
    if (oldFile == null) {
        return (false);
    }

    var newFile = File.open(nf, "w");

    /* The last component is removed because it is kept in the bundle, so the
     * relative paths need to include it.
     */
    var lastComp = srcDir.substr(srcDir.lastIndexOf('/') + 1);

    var inputFlag = false;
    var line;
    while ((line = oldFile.readLine()) != null) {
        var newLine = line;

        /* srcDir always goes first because it should never match the name of
         * any other repository. But, the case where another repository is a
         * substring of srcDir is allowed. But we still leave the last
         * component of the path in the new name because the user may need to
         * recognize the path for the generated libraries.
         */
        if (srcDir != "") {
            var regexp = new RegExp(srcDir, "gi");
            newLine = newLine.replace(regexp, lastComp);

            var srcDirInv = srcDir.replace(/\//g, "\\\\");
            regexp = new RegExp(srcDirInv, "gi");
            newLine = newLine.replace(regexp, lastComp);
        }

        if (exePath != "") {
            var regexp = new RegExp(exePath, "gi");
            newLine = newLine.replace(regexp, "");

            var exePathInv = exePath.replace(/\//g, "\\\\");
            regexp = new RegExp(exePathInv, "gi");
            newLine = newLine.replace(regexp, "");
        }

        for (var prop in reps) {
            if (prop[prop.length - 1] != '/') {
                prop = prop + "/";
            }
            var regexp = new RegExp(prop, "gi");
            newLine = newLine.replace(regexp, "");

            prop = prop.replace(/\//g, "\\\\");
            regexp = new RegExp(prop);
            newLine = newLine.replace(regexp, "");
        }

        /* We are assuming that if we find something in quotes, it's the name
         * of a library, an object file, or a linker command file. That works
         * for TI targets and some GNU targets. For GNU targets, we can also
         * look for 'INPUT(' and the ')' to determine the strings that
         * represent libraries.
         */
        var wholeMatch = newLine.match(/^\s*(?:-l)?\s*"([^"]*)"\s*$/);

        /* A line matching ')' is the end of the INPUT directive for gnu */
        if (inputFlag && newLine.match(/\)/)) {
            inputFlag = false;
        }

        var newLib = null;
        if (!inputFlag) {
            if (wholeMatch) {
                newLib = wholeMatch[1];
                if (newLine.substring(0, 2) != "-l"
                    && tname.search("ti.targets") == 0) {
                    newLine = "-l" + newLine;
                }
            }
        }
        else {
            if (!wholeMatch) {
                newLib = newLine.match(/\S+/)[0];
            }
            else {
                newLib = wholeMatch[1];
            }
        }
        if (newLine.match(/INPUT/)) {
            inputFlag = true;
        }
        if (newLib) {
            lib[counter++] = newLib.replace(/\\/g, '/').replace(/\/\/+/g, '/');
        }

        newFile.writeLine(newLine);
    }
    newFile.close();
    oldFile.close();

    if (vfl) {
        print(of + " processed and copied to " + nf);
    }

    return (lib);
}

/*
 *  ======== _backup ========
 */
function _backup(oldName, newName)
{
    var o = new java.io.File(oldName);
    var n = new java.io.File(newName);
    if (o.exists() && !n.exists()) {
        return (o.renameTo(n));
    }
    else {
        return (false);
    }
}

/*
 *  ======== _openXML ========
 */
function _openXML(fileName)
{
    var f = new java.io.File(fileName);
    if (!f.exists()) {
        return (null);
    }
    return (xdc.loadXML(fileName));
}

/*
 *  ======== _unixJSPath ========
 *  Function that converts Java String into a JavaScript String and replaces
 *  backslashes with forward slashes
 */
function _unixJSPath(fileName)
{
    return (fileName + "").replace(/\\/g, "/");
}

/*
 *  ======== _copy ========
 *  copy file named 'of' to 'nf'
 */
function _copy(of, nf)
{
    var ins = new java.io.FileInputStream(of);
    var outs = new java.io.FileOutputStream(nf, true);
    var inc = ins.getChannel();
    var outc = outs.getChannel();

    inc.transferTo(0, inc.size(), outc);

    inc.close();
    outc.close();
    ins.close();
    outs.close();
}
/*
 *  @(#) xdc.tools.closure; 1, 0, 0,0; 1-9-2017 12:51:22; /db/ztree/library/trees/xdctools/xdctools-h00/src/
 */

